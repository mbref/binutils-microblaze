diff -purN --exclude=.gitignore --exclude=.git --exclude=patches binutils-microblaze/bfd/bfd-in2.h git.xilinx.com_microblaze-gnu_src_binutils/bfd/bfd-in2.h
--- binutils-microblaze/bfd/bfd-in2.h	2012-10-07 16:26:10.474077418 +0200
+++ git.xilinx.com_microblaze-gnu_src_binutils/bfd/bfd-in2.h	2012-09-28 23:25:50.142841951 +0200
@@ -1392,6 +1392,21 @@ typedef struct bfd_section
   /* Bits used by various backends.  The generic code doesn't touch
      these fields.  */
 
+  /* Nonzero if this section has TLS related relocations.  */
+  unsigned int has_tls_reloc:1;
+
+  /* Nonzero if this section has a call to __tls_get_addr.  */
+  unsigned int has_tls_get_addr_call:1;
+
+  /* Nonzero if this section has a gp reloc.  */
+  unsigned int has_gp_reloc:1;
+
+  /* Nonzero if this section needs the relax finalize pass.  */
+  unsigned int need_finalize_relax:1;
+
+  /* Whether relocations have been processed.  */
+  unsigned int reloc_done : 1;
+
   unsigned int sec_flg0:1;
   unsigned int sec_flg1:1;
   unsigned int sec_flg2:1;
@@ -1671,14 +1686,17 @@ extern asection bfd_ind_section;
   /* linker_mark, linker_has_input, gc_mark, decompress_status,    */  \
      0,           0,                1,       0,                        \
                                                                        \
-  /* segment_mark, sec_info_type, use_rela_p,                      */  \
-     0,            0,             0,                                   \
+  /* segment_mark, sec_info_type, use_rela_p, has_tls_reloc,       */  \
+     0,            0,             0,          0,                       \
+                                                                       \
+  /* has_tls_get_addr_call, has_gp_reloc, need_finalize_relax,     */  \
+     0,                     0,            0,                           \
                                                                        \
   /* sec_flg0, sec_flg1, sec_flg2, sec_flg3, sec_flg4, sec_flg5,   */  \
      0,        0,        0,        0,        0,        0,              \
                                                                        \
-  /* vma, lma, size, rawsize, compressed_size, relax, relax_count, */  \
-     0,   0,   0,    0,       0,               0,     0,               \
+  /* reloc_done, vma, lma, size, rawsize, compressed_size, relax, relax_count, */  \
+     0,   0,   0,   0,    0,       0,               0,     0,               \
                                                                        \
   /* output_offset, output_section,              alignment_power,  */  \
      0,             (struct bfd_section *) &SEC, 0,                    \
@@ -4819,6 +4837,7 @@ expressions of the form "Symbol Op Symbo
 /* This is a 64 bit reloc that stores the 32 bit pc relative 
 value in two words (with an imm instruction).  No relocation is 
 done here - only used for relaxing  */
+  BFD_RELOC_MICROBLAZE_32_NONE,
   BFD_RELOC_MICROBLAZE_64_NONE,
 
 /* This is a 64 bit reloc that stores the 32 bit pc relative 
@@ -4849,6 +4868,37 @@ value in a word.  The relocation is rela
 the dynamic object into the runtime process image.  */
   BFD_RELOC_MICROBLAZE_COPY,
 
+/* Unused Reloc  */
+  BFD_RELOC_MICROBLAZE_64_TLS,
+
+/* This is a 64 bit reloc that stores the 32 bit GOT relative value
+of the GOT TLS GD info entry in two words (with an imm instruction). The 
+relocation is GOT offset.  */
+  BFD_RELOC_MICROBLAZE_64_TLSGD,
+
+/* This is a 64 bit reloc that stores the 32 bit GOT relative value
+of the GOT TLS LD info entry in two words (with an imm instruction). The 
+relocation is GOT offset.  */
+  BFD_RELOC_MICROBLAZE_64_TLSLD,
+
+/* This is a 32 bit reloc that stores the Module ID to GOT(n).  */
+  BFD_RELOC_MICROBLAZE_32_TLSDTPMOD,
+
+/* This is a 32 bit reloc that stores TLS offset to GOT(n+1).  */
+  BFD_RELOC_MICROBLAZE_32_TLSDTPREL,
+
+/* This is a 32 bit reloc for storing TLS offset to two words (uses imm 
+instruction)  */
+  BFD_RELOC_MICROBLAZE_64_TLSDTPREL,
+
+/* This is a 64 bit reloc that stores 32-bit thread pointer relative offset
+to two words (uses imm instruction).  */
+  BFD_RELOC_MICROBLAZE_64_TLSGOTTPREL,
+
+/* This is a 64 bit reloc that stores 32-bit thread pointer relative offset
+to two words (uses imm instruction).  */
+  BFD_RELOC_MICROBLAZE_64_TLSTPREL,
+
 /* Tilera TILEPro Relocations.  */
   BFD_RELOC_TILEPRO_COPY,
   BFD_RELOC_TILEPRO_GLOB_DAT,
diff -purN --exclude=.gitignore --exclude=.git --exclude=patches binutils-microblaze/bfd/config.bfd git.xilinx.com_microblaze-gnu_src_binutils/bfd/config.bfd
--- binutils-microblaze/bfd/config.bfd	2012-10-07 16:26:10.494053353 +0200
+++ git.xilinx.com_microblaze-gnu_src_binutils/bfd/config.bfd	2012-09-28 23:25:50.407216441 +0200
@@ -868,8 +868,14 @@ case "${targ}" in
     targ_selvecs=bfd_elf32_mep_little_vec
     ;;
 
+  microblazeel*-*)
+    targ_defvec=bfd_elf32_microblazeel_vec
+    targ_selvecs=bfd_elf32_microblaze_vec
+    ;;
+
   microblaze*-*)
     targ_defvec=bfd_elf32_microblaze_vec
+    targ_selvecs=bfd_elf32_microblazeel_vec
     ;;
 
   mips*-big-*)
diff -purN --exclude=.gitignore --exclude=.git --exclude=patches binutils-microblaze/bfd/configure git.xilinx.com_microblaze-gnu_src_binutils/bfd/configure
--- binutils-microblaze/bfd/configure	2012-10-07 16:26:10.504077079 +0200
+++ git.xilinx.com_microblaze-gnu_src_binutils/bfd/configure	2012-09-28 23:25:50.417217576 +0200
@@ -15245,6 +15245,7 @@ do
     bfd_elf32_mcore_little_vec)	tb="$tb elf32-mcore.lo elf32.lo $elf" ;;
     bfd_elf32_mep_vec)		tb="$tb elf32-mep.lo elf32.lo $elf" ;;
     bfd_elf32_mep_little_vec)	tb="$tb elf32-mep.lo elf32.lo $elf" ;;
+    bfd_elf32_microblazeel_vec)	tb="$tb elf32-microblaze.lo elf32.lo $elf" ;;
     bfd_elf32_microblaze_vec)	tb="$tb elf32-microblaze.lo elf32.lo $elf" ;;
     bfd_elf32_mn10200_vec)	tb="$tb elf-m10200.lo elf32.lo $elf" ;;
     bfd_elf32_mn10300_vec)	tb="$tb elf-m10300.lo elf32.lo $elf" ;;
diff -purN --exclude=.gitignore --exclude=.git --exclude=patches binutils-microblaze/bfd/configure.in git.xilinx.com_microblaze-gnu_src_binutils/bfd/configure.in
--- binutils-microblaze/bfd/configure.in	2012-10-07 16:26:10.504077079 +0200
+++ git.xilinx.com_microblaze-gnu_src_binutils/bfd/configure.in	2012-09-28 23:25:50.472841297 +0200
@@ -744,6 +744,7 @@ do
     bfd_elf32_mcore_little_vec)	tb="$tb elf32-mcore.lo elf32.lo $elf" ;;
     bfd_elf32_mep_vec)		tb="$tb elf32-mep.lo elf32.lo $elf" ;;
     bfd_elf32_mep_little_vec)	tb="$tb elf32-mep.lo elf32.lo $elf" ;;
+    bfd_elf32_microblazeel_vec)	tb="$tb elf32-microblaze.lo elf32.lo $elf" ;;
     bfd_elf32_microblaze_vec)	tb="$tb elf32-microblaze.lo elf32.lo $elf" ;;
     bfd_elf32_mn10200_vec)	tb="$tb elf-m10200.lo elf32.lo $elf" ;;
     bfd_elf32_mn10300_vec)	tb="$tb elf-m10300.lo elf32.lo $elf" ;;
diff -purN --exclude=.gitignore --exclude=.git --exclude=patches binutils-microblaze/bfd/elf32-microblaze.c git.xilinx.com_microblaze-gnu_src_binutils/bfd/elf32-microblaze.c
--- binutils-microblaze/bfd/elf32-microblaze.c	2012-10-07 16:26:11.294350942 +0200
+++ git.xilinx.com_microblaze-gnu_src_binutils/bfd/elf32-microblaze.c	2012-09-28 23:25:51.733357214 +0200
@@ -177,6 +177,20 @@ static reloc_howto_type microblaze_elf_h
           FALSE), 		/* PC relative offset?  */
 
    /* This reloc does nothing.  Used for relaxation.  */
+   HOWTO (R_MICROBLAZE_32_NONE,	/* Type.  */
+          0,			/* Rightshift.  */
+          2,			/* Size (0 = byte, 1 = short, 2 = long).  */
+          32,			/* Bitsize.  */
+          TRUE,			/* PC_relative.  */
+          0,			/* Bitpos.  */
+          complain_overflow_bitfield,  /* Complain on overflow.  */
+          NULL,                  /* Special Function.  */
+          "R_MICROBLAZE_32_NONE",/* Name.  */
+          FALSE,		/* Partial Inplace.  */
+          0,			/* Source Mask.  */
+          0,			/* Dest Mask.  */
+          FALSE),		/* PC relative offset?  */
+
    HOWTO (R_MICROBLAZE_64_NONE,	/* Type.  */
           0,			/* Rightshift.  */
           2,			/* Size (0 = byte, 1 = short, 2 = long).  */
@@ -370,6 +384,132 @@ static reloc_howto_type microblaze_elf_h
           0,			/* Source Mask.  */
           0x0000ffff,		/* Dest Mask.  */
           FALSE), 		/* PC relative offset?  */
+
+  /* Marker relocs for TLS.  */
+  HOWTO (R_MICROBLAZE_TLS,
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MICROBLAZE_TLS",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_MICROBLAZE_TLSGD,
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_MICROBLAZE_TLSGD",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_MICROBLAZE_TLSLD,
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_MICROBLAZE_TLSLD",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Computes the load module index of the load module that contains the
+     definition of its TLS sym.  */
+  HOWTO (R_MICROBLAZE_TLSDTPMOD32,
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_MICROBLAZE_TLSDTPMOD32",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Computes a dtv-relative displacement, the difference between the value
+     of sym+add and the base address of the thread-local storage block that
+     contains the definition of sym, minus 0x8000.  Used for initializing GOT */
+  HOWTO (R_MICROBLAZE_TLSDTPREL32,
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_MICROBLAZE_TLSDTPREL32",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Computes a dtv-relative displacement, the difference between the value
+     of sym+add and the base address of the thread-local storage block that
+     contains the definition of sym, minus 0x8000.  */
+  HOWTO (R_MICROBLAZE_TLSDTPREL64,
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_MICROBLAZE_TLSDTPREL64",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Computes a tp-relative displacement, the difference between the value of
+     sym+add and the value of the thread pointer (r13).  */
+  HOWTO (R_MICROBLAZE_TLSGOTTPREL32,
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_MICROBLAZE_TLSGOTTPREL32",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Computes a tp-relative displacement, the difference between the value of
+     sym+add and the value of the thread pointer (r13).  */
+  HOWTO (R_MICROBLAZE_TLSTPREL32,
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_MICROBLAZE_TLSTPREL32",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
 };
 
 #ifndef NUM_ELEM
@@ -406,7 +546,10 @@ microblaze_elf_reloc_type_lookup (bfd * 
     case BFD_RELOC_NONE:
       microblaze_reloc = R_MICROBLAZE_NONE;
       break;
-    case BFD_RELOC_MICROBLAZE_64_NONE:
+    case BFD_RELOC_MICROBLAZE_32_NONE:
+      microblaze_reloc = R_MICROBLAZE_32_NONE;
+      break;
+     case BFD_RELOC_MICROBLAZE_64_NONE:
       microblaze_reloc = R_MICROBLAZE_64_NONE;
       break;
     case BFD_RELOC_32:
@@ -461,6 +604,27 @@ microblaze_elf_reloc_type_lookup (bfd * 
     case BFD_RELOC_MICROBLAZE_32_GOTOFF:
       microblaze_reloc = R_MICROBLAZE_GOTOFF_32;
       break;
+    case BFD_RELOC_MICROBLAZE_64_TLSGD:
+      microblaze_reloc = R_MICROBLAZE_TLSGD;
+      break;
+    case BFD_RELOC_MICROBLAZE_64_TLSLD:
+      microblaze_reloc = R_MICROBLAZE_TLSLD;
+      break;
+    case BFD_RELOC_MICROBLAZE_32_TLSDTPREL:
+      microblaze_reloc = R_MICROBLAZE_TLSDTPREL32;
+      break;
+    case BFD_RELOC_MICROBLAZE_64_TLSDTPREL:
+      microblaze_reloc = R_MICROBLAZE_TLSDTPREL64;
+      break;
+    case BFD_RELOC_MICROBLAZE_32_TLSDTPMOD:
+      microblaze_reloc = R_MICROBLAZE_TLSDTPMOD32;
+      break;
+    case BFD_RELOC_MICROBLAZE_64_TLSGOTTPREL:
+      microblaze_reloc = R_MICROBLAZE_TLSGOTTPREL32;
+      break;
+    case BFD_RELOC_MICROBLAZE_64_TLSTPREL:
+      microblaze_reloc = R_MICROBLAZE_TLSTPREL32;
+      break;
     case BFD_RELOC_MICROBLAZE_COPY:
       microblaze_reloc = R_MICROBLAZE_COPY;
       break;
@@ -550,8 +714,21 @@ struct elf32_mb_link_hash_entry
   /* Track dynamic relocs copied for this symbol.  */
   struct elf32_mb_dyn_relocs *dyn_relocs;
 
+  /* TLS Reference Types for the symbol; Updated by check_relocs */
+#define TLS_GD		 1	/* GD reloc. */
+#define TLS_LD		 2	/* LD reloc. */
+#define TLS_TPREL	 4	/* TPREL reloc, => IE. */
+#define TLS_DTPREL	 8	/* DTPREL reloc, => LD. */
+#define TLS_TLS		16	/* Any TLS reloc.  */
+  unsigned char tls_mask;
+
 };
 
+#define IS_TLS_GD(x)   (x == (TLS_TLS | TLS_GD))
+#define IS_TLS_LD(x)   (x == (TLS_TLS | TLS_LD))
+#define IS_TLS_DTPREL(x)   (x == (TLS_TLS | TLS_DTPREL))
+#define IS_TLS_NONE(x) (x == 0)
+
 #define elf32_mb_hash_entry(ent) ((struct elf32_mb_link_hash_entry *)(ent))
 
 /* ELF linker hash table.  */
@@ -571,6 +748,12 @@ struct elf32_mb_link_hash_table
 
   /* Small local sym to section mapping cache.  */
   struct sym_cache sym_sec;
+
+  /* TLS Local Dynamic GOT Entry */
+  union {
+    bfd_signed_vma refcount;
+    bfd_vma offset;
+  } tlsld_got;
 };
 
 /* Get the ELF linker hash table from a link_info structure.  */
@@ -604,6 +787,7 @@ link_hash_newfunc (struct bfd_hash_entry
 
       eh = (struct elf32_mb_link_hash_entry *) entry;
       eh->dyn_relocs = NULL;
+      eh->tls_mask = 0;
     }
 
   return entry;
@@ -654,6 +838,79 @@ microblaze_elf_final_sdp (struct bfd_lin
                              + h->u.def.section->output_offset);
 }
 
+static bfd_vma
+dtprel_base (struct bfd_link_info *info)
+{
+  /* If tls_sec is NULL, we should have signalled an error already.  */
+  if (elf_hash_table (info)->tls_sec == NULL)
+    return 0;
+  return elf_hash_table (info)->tls_sec->vma; 
+}
+
+/* The size of the thread control block.  */
+#define TCB_SIZE	8
+
+#if 0
+static bfd_vma
+tprel_base (struct bfd_link_info *info)
+{
+  bfd_vma base;
+
+  /* If tls_sec is NULL, we should have signalled an error already.  */
+  if (elf_hash_table (info)->tls_sec == NULL)
+    return 0;
+  base = align_power ((bfd_vma) TCB_SIZE, elf_hash_table(info)->tls_sec->alignment_power);
+
+  return elf_hash_table (info)->tls_sec->vma - base;
+}
+#endif
+
+static void
+check_unique_offset(bfd_vma offset, int tls_type, bfd_vma v)
+{
+  static bfd_vma offsets[1000];
+  static bfd_vma values[1000];
+
+  static int noffsets = 0;
+  int scan1;
+
+  return;
+
+  for (scan1 = 0; scan1 < noffsets; scan1++)
+  {
+	if (offsets[scan1] == offset)
+	  {
+		fprintf (stderr, "Duplicate Offset: %lx type: %x Old: %lx New: %lx \n", offset, tls_type, values[scan1], v);
+	  }
+  }
+  fprintf (stderr, "%d Registered Offset: %lx Value: %lx type: %x\n", noffsets, offset, v, tls_type);
+  offsets[noffsets] = offset;
+  values[noffsets++] = v;
+}
+
+/* Output a simple dynamic relocation into SRELOC.  */
+
+static void
+microblaze_elf_output_dynamic_relocation (bfd *output_bfd,
+				    asection *sreloc,
+				    unsigned long reloc_index,
+				    unsigned long indx,
+				    int r_type,
+				    bfd_vma offset,
+				    bfd_vma addend
+                                    )
+{
+
+  Elf_Internal_Rela rel;
+
+  rel.r_info = ELF32_R_INFO (indx, r_type);
+  rel.r_offset = offset;
+  rel.r_addend = addend;
+
+  bfd_elf32_swap_reloca_out (output_bfd, &rel, 
+              (sreloc->contents + reloc_index * sizeof (Elf32_External_Rela)));
+}
+
 /* This code is taken from elf32-m32r.c
    There is some attempt to make this function usable for many architectures,
    both USE_REL and USE_RELA ['twould be nice if such a critter existed],
@@ -702,10 +959,12 @@ microblaze_elf_relocate_section (bfd *ou
   Elf_Internal_Shdr *symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
   struct elf_link_hash_entry **sym_hashes = elf_sym_hashes (input_bfd);
   Elf_Internal_Rela *rel, *relend;
+  int endian = !bfd_little_endian (output_bfd) * 2;
   /* Assume success.  */
   bfd_boolean ret = TRUE;
   asection *sreloc;
   bfd_vma *local_got_offsets;
+  unsigned int tls_type;
 
   if (!microblaze_elf_howto_table[R_MICROBLAZE_max-1])
     microblaze_elf_howto_init ();
@@ -737,6 +996,8 @@ microblaze_elf_relocate_section (bfd *ou
 
       h = NULL;
       r_type = ELF32_R_TYPE (rel->r_info);
+      tls_type = 0;
+
       if (r_type < 0 || r_type >= (int) R_MICROBLAZE_max)
 	{
 	  (*_bfd_error_handler) (_("%s: unknown relocation type %d"),
@@ -933,9 +1194,9 @@ microblaze_elf_relocate_section (bfd *ou
 			     + offset + INST_WORD_SIZE);
 	      relocation += addend;
 	      bfd_put_16 (input_bfd, (relocation >> 16) & 0xffff,
-			  contents + offset + 2);
+			  contents + offset + endian);
 	      bfd_put_16 (input_bfd, relocation & 0xffff,
-			  contents + offset + 2 + INST_WORD_SIZE);
+			  contents + offset + endian + INST_WORD_SIZE);
 	      break;
 
 	    case (int) R_MICROBLAZE_PLT_64:
@@ -952,9 +1213,9 @@ microblaze_elf_relocate_section (bfd *ou
 					      + input_section->output_offset
 					      + offset + INST_WORD_SIZE);
 		    bfd_put_16 (input_bfd, (immediate >> 16) & 0xffff,
-				contents + offset + 2);
+				contents + offset + endian);
 		    bfd_put_16 (input_bfd, immediate & 0xffff,
-				contents + offset + 2 + INST_WORD_SIZE);
+				contents + offset + endian + INST_WORD_SIZE);
 		  }
 		else
 		  {
@@ -963,77 +1224,215 @@ microblaze_elf_relocate_section (bfd *ou
 				   + offset + INST_WORD_SIZE);
 		    immediate = relocation;
 		    bfd_put_16 (input_bfd, (immediate >> 16) & 0xffff,
-				contents + offset + 2);
+				contents + offset + endian);
 		    bfd_put_16 (input_bfd, immediate & 0xffff,
-				contents + offset + 2 + INST_WORD_SIZE);
+				contents + offset + endian + INST_WORD_SIZE);
 		  }
 		break;
 	      }
 
+	    case (int) R_MICROBLAZE_TLSGD:
+		tls_type = (TLS_TLS | TLS_GD);
+		goto dogot;
+	    case (int) R_MICROBLAZE_TLSLD:
+		tls_type = (TLS_TLS | TLS_LD);
+		dogot:
 	    case (int) R_MICROBLAZE_GOT_64:
 	      {
+	        bfd_vma *offp;
+                bfd_vma off, off2;
+	        unsigned long indx;
+		bfd_vma static_value;
+
+		bfd_boolean need_relocs = FALSE;
+
 		if (htab->sgot == NULL)
 		  abort ();
-		if (h == NULL)
-		  {
-		    bfd_vma off;
+
+	        indx = 0;
+	        offp = NULL;
+
+                /* 1. Identify GOT Offset; 
+                   2. Compute Static Values 
+                   3. Process Module Id, Process Offset
+                   4. Fixup Relocation with GOT offset value 
+                 */
+                   
+                /* 1. Determine GOT Offset to use : TLS_LD, global, local */
+	        if ( IS_TLS_LD (tls_type) )
+	          offp = &htab->tlsld_got.offset;
+                else if (h != NULL)
+	          {
+		    if (htab->sgotplt != NULL && h->got.offset != (bfd_vma) -1)
+		       offp = &h->got.offset;
+                    else
+		      abort ();
+	          }
+	        else
+	          {
 		    if (local_got_offsets == NULL)
 		      abort ();
-		    off = local_got_offsets[r_symndx];
-		    /* The LSB indicates whether we've already
-		       created relocation.  */
-		    if (off & 1)
-		      off &= ~1;
-		    else
-		      {
-			bfd_put_32 (output_bfd, relocation + addend,
-				    htab->sgot->contents + off);
+		    offp = &local_got_offsets[r_symndx];
+	          }
 
-			if (info->shared)
-			  {
-			    Elf_Internal_Rela outrel;
-			    bfd_byte *loc;
-			    if (htab->srelgot == NULL)
-			      abort ();
-			    outrel.r_offset = (htab->sgot->output_section->vma
-					       + htab->sgot->output_offset
-					       + off);
-			    outrel.r_info = ELF32_R_INFO (0, R_MICROBLAZE_REL);
-			    outrel.r_addend = relocation + addend;
-			    loc = htab->srelgot->contents;
-			    loc += htab->srelgot->reloc_count++
-			      * sizeof (Elf32_External_Rela);
-			    bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
-			  }
-			local_got_offsets[r_symndx] |= 1;
-		      }
-		    relocation = htab->sgot->output_section->vma
-		      + htab->sgot->output_offset + off
-		      - htab->sgotplt->output_section->vma
-		      - htab->sgotplt->output_offset;
-		    unresolved_reloc = FALSE;
-		  }
-		else
-		  {
-		    if (htab->sgotplt != NULL && h != NULL
-			&& h->got.offset != (bfd_vma) -1)
-		      {
-			bfd_put_32 (output_bfd, relocation + addend,
-				    htab->sgot->contents + h->got.offset);
-			relocation = htab->sgot->output_section->vma
-			  + htab->sgot->output_offset
-			  + h->got.offset
-			  - htab->sgotplt->output_section->vma
-			  - htab->sgotplt->output_offset;
-			unresolved_reloc = FALSE;
-		      }
-		    else
-		      abort (); /* ??? */
-		  }
+                if ( !offp ) abort();
+
+                off = (*offp) & ~1;
+                off2 = off;
+
+                if (IS_TLS_LD(tls_type) || IS_TLS_GD(tls_type))
+                  off2 = off + 4;
+
+                /* Symbol index to use for relocs */
+                if (h != NULL)
+                  {
+                    bfd_boolean dyn = 
+                      elf_hash_table (info)->dynamic_sections_created;
+
+                    if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
+	                && (!info->shared || 
+                            !SYMBOL_REFERENCES_LOCAL (info, h)))
+	              indx = h->dynindx;
+                  }
+
+                /* Need to generate relocs ? */ 
+                if ((info->shared || indx != 0)
+                    && (h == NULL
+	                || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
+	                || h->root.type != bfd_link_hash_undefweak))
+                  need_relocs = TRUE;
+
+		/* 2. Compute/Emit Static value of r-expression */
+		static_value = relocation + addend;
+
+		/* 3. Process module-id and offset */
+                if (! ((*offp) & 1) )
+                  {
+		     bfd_vma got_offset;
+
+ 		     got_offset = (htab->sgot->output_section->vma
+    				       + htab->sgot->output_offset
+    				       + off);
+
+                    /* Process module-id */
+                    if (IS_TLS_LD(tls_type))
+                      {
+
+                        if ( ! info->shared )
+                          {
+                            check_unique_offset( off, tls_type, 1);
+
+    		            bfd_put_32 (output_bfd, 1,
+    			         htab->sgot->contents + off);
+                          }
+                        else
+                          {
+                            check_unique_offset( off, tls_type, 0xDDDDDDDD);
+
+                            microblaze_elf_output_dynamic_relocation (
+                                  output_bfd, htab->srelgot,
+    			      htab->srelgot->reloc_count++,
+    			      /* symindex= */ 0,
+    			      R_MICROBLAZE_TLSDTPMOD32,
+    			      got_offset, 0);
+                          }
+                      }
+                    else if (IS_TLS_GD(tls_type))
+                      {
+                        if ( ! need_relocs )
+                          {
+                            check_unique_offset( off, tls_type, 1);
+
+    		            bfd_put_32 (output_bfd, 1,
+    			         htab->sgot->contents + off);
+                          }
+                        else
+                          {
+                            check_unique_offset( off, tls_type, 0);
+
+                            microblaze_elf_output_dynamic_relocation (
+                                  output_bfd, htab->srelgot,
+    			      htab->srelgot->reloc_count++,
+    			      /* symindex= */ indx,
+    			      R_MICROBLAZE_TLSDTPMOD32,
+    			      got_offset, indx ? 0 : static_value);
+                          }
+                      }
+    
+                    /* Process Offset */
+    		    if (htab->srelgot == NULL)
+    		      abort ();
+    
+    		    got_offset = (htab->sgot->output_section->vma
+    					       + htab->sgot->output_offset
+    					       + off2);
+                    if (IS_TLS_LD(tls_type))
+                      {
+                        /* For LD, offset should be 0 */
+                        *offp |= 1;
+    		        bfd_put_32 (output_bfd, 0, htab->sgot->contents + off2);
+                      }
+                    else if (IS_TLS_GD(tls_type))
+                      {
+     		        *offp |= 1;
+                        static_value -= dtprel_base(info);
+                        if (need_relocs)
+                          {
+                            check_unique_offset(off2, tls_type, indx ? 0 : static_value + 1);
+                            microblaze_elf_output_dynamic_relocation (
+                                  output_bfd, htab->srelgot,
+    			      htab->srelgot->reloc_count++,
+    			      /* symindex= */ indx,
+    			      R_MICROBLAZE_TLSDTPREL32,
+    			      got_offset, indx ? 0 : static_value);
+                          }
+                        else
+                          {
+                            check_unique_offset(off2, tls_type, static_value);
+
+    		            bfd_put_32 (output_bfd, static_value,
+    				    htab->sgot->contents + off2);
+                          }
+                      }
+                    else
+                      {
+    		         bfd_put_32 (output_bfd, static_value,
+    			    htab->sgot->contents + off2);
+    
+                         /* Relocs for dyn symbols generated by
+                            finish_dynamic_symbols */
+                         if (info->shared && h == NULL)
+                           {
+     		              *offp |= 1;
+
+                              check_unique_offset(off2, tls_type, static_value);
+
+                              microblaze_elf_output_dynamic_relocation (
+                                output_bfd, htab->srelgot,
+    			        htab->srelgot->reloc_count++,
+    			        /* symindex= */ indx,
+    			        R_MICROBLAZE_REL,
+    			        got_offset, static_value);
+                           }
+                      }
+                  }
+
+                /* 4. Fixup Relocation with GOT offset value */
+                /* Compute relative address of GOT entry for applying
+                         the current relocation */
+		relocation = htab->sgot->output_section->vma
+		    + htab->sgot->output_offset
+		    + off
+		    - htab->sgotplt->output_section->vma
+		    - htab->sgotplt->output_offset;
+
+                /* Apply Current Relocation */
 		bfd_put_16 (input_bfd, (relocation >> 16) & 0xffff,
-			    contents + offset + 2);
+			    contents + offset + endian);
 		bfd_put_16 (input_bfd, relocation & 0xffff,
-			    contents + offset + 2 + INST_WORD_SIZE);
+			    contents + offset + endian + INST_WORD_SIZE);
+
+		unresolved_reloc = FALSE;
 		break;
 	      }
 
@@ -1048,8 +1447,8 @@ microblaze_elf_relocate_section (bfd *ou
 		immediate = relocation;
 		lo = immediate & 0x0000ffff;
 		high = (immediate >> 16) & 0x0000ffff;
-		bfd_put_16 (input_bfd, high, contents + offset + 2);
-		bfd_put_16 (input_bfd, lo, contents + offset + INST_WORD_SIZE + 2);
+		bfd_put_16 (input_bfd, high, contents + offset + endian);
+		bfd_put_16 (input_bfd, lo, contents + offset + INST_WORD_SIZE + endian);
 		break;
 	      }
 
@@ -1063,6 +1462,14 @@ microblaze_elf_relocate_section (bfd *ou
 		break;
 	      }
 
+	    case (int) R_MICROBLAZE_TLSDTPREL64:
+		 relocation += addend;
+                 relocation -= dtprel_base(info);
+		 bfd_put_16 (input_bfd, (relocation >> 16) & 0xffff,
+				    contents + offset + 2);
+		 bfd_put_16 (input_bfd, relocation & 0xffff,
+				    contents + offset + 2 + INST_WORD_SIZE);
+		break;
 	    case (int) R_MICROBLAZE_64_PCREL :
 	    case (int) R_MICROBLAZE_64:
 	    case (int) R_MICROBLAZE_32:
@@ -1081,10 +1488,11 @@ microblaze_elf_relocate_section (bfd *ou
 			  relocation -= (input_section->output_section->vma
 					 + input_section->output_offset
 					 + offset + INST_WORD_SIZE);
+
 			bfd_put_16 (input_bfd, (relocation >> 16) & 0xffff,
-				    contents + offset + 2);
+				    contents + offset + endian);
 			bfd_put_16 (input_bfd, relocation & 0xffff,
-				    contents + offset + 2 + INST_WORD_SIZE);
+				    contents + offset + endian + INST_WORD_SIZE);
 		      }
 		    break;
 		  }
@@ -1176,9 +1584,9 @@ microblaze_elf_relocate_section (bfd *ou
 					 + input_section->output_offset
 					 + offset + INST_WORD_SIZE);
 			bfd_put_16 (input_bfd, (relocation >> 16) & 0xffff,
-				    contents + offset + 2);
+				    contents + offset + endian);
 			bfd_put_16 (input_bfd, relocation & 0xffff,
-				    contents + offset + 2 + INST_WORD_SIZE);
+				    contents + offset + endian + INST_WORD_SIZE);
 		      }
 		    break;
 		  }
@@ -1253,9 +1661,49 @@ microblaze_elf_relocate_section (bfd *ou
 
   return ret;
 }
+
+/* Merge backend specific data from an object file to the output
+   object file when linking.  
+
+   Note: We only use this hook to catch endian mismatches */
+static bfd_boolean
+microblaze_elf_merge_private_bfd_data (bfd * ibfd, bfd * obfd)
+{
+  /* Check if we have the same endianess.  */
+  if (! _bfd_generic_verify_endian_match (ibfd, obfd))
+    return FALSE;
+
+  return TRUE;
+}
+
 
 /* Calculate fixup value for reference.  */
 
+#define D(x)
+
+static int
+calc_size_fixup (bfd_vma start, bfd_vma size, asection *sec)
+{
+  bfd_vma end = start + size;
+  int i, fixup = 0;
+
+  if (sec == NULL || sec->relax == NULL)
+    return 0;
+
+  /* Look for addr in relax table, total fixup value.  */
+  for (i = 0; i < sec->relax_count; i++)
+    {
+      D(fprintf(stderr, "%s: start=%x end=%x reladdr=%x relsize=%d\n", __func__,
+		start, end, sec->relax[i].addr, sec->relax[i].size));
+      if (end < sec->relax[i].addr)
+        break;
+      if (start > sec->relax[i].addr)
+        continue;
+      fixup += sec->relax[i].size;
+    }
+  return fixup;
+}
+
 static int
 calc_fixup (bfd_vma addr, asection *sec)
 {
@@ -1275,6 +1723,36 @@ calc_fixup (bfd_vma addr, asection *sec)
   return fixup;
 }
 
+/* Read-modify-write into the bfd, an immediate value into appropriate fields of a 32-bit
+ * instruction. */
+static void
+microblaze_bfd_write_imm_value_32 (bfd *abfd, bfd_byte *bfd_addr, bfd_vma val) 
+{
+    unsigned long instr = bfd_get_32 (abfd, bfd_addr);
+    instr &= ~0x0000ffff;
+    instr |= (val & 0x0000ffff);
+    bfd_put_32 (abfd, instr, bfd_addr);
+}
+
+/* Read-modify-write into the bfd, an immediate value into appropriate fields of
+ * two consecutive 32-bit instructions. */
+static void 
+microblaze_bfd_write_imm_value_64 (bfd *abfd, bfd_byte *bfd_addr, bfd_vma val)
+{
+    unsigned long instr_hi;
+    unsigned long instr_lo;
+
+    instr_hi = bfd_get_32 (abfd, bfd_addr);
+    instr_hi &= ~0x0000ffff;
+    instr_hi |= ((val >> 16) & 0x0000ffff);           
+    bfd_put_32 (abfd, instr_hi, bfd_addr);
+
+    instr_lo = bfd_get_32 (abfd, bfd_addr + INST_WORD_SIZE);
+    instr_lo &= ~0x0000ffff;
+    instr_lo |= (val & 0x0000ffff);           
+    bfd_put_32 (abfd, instr_lo, bfd_addr + INST_WORD_SIZE);   
+}
+
 static bfd_boolean
 microblaze_elf_relax_section (bfd *abfd,
 			      asection *sec,
@@ -1305,7 +1783,8 @@ microblaze_elf_relax_section (bfd *abfd,
   /* Only do this for a text section.  */
   if (link_info->relocatable
       || (sec->flags & SEC_RELOC) == 0
-      || (sec->reloc_count == 0))
+      || (sec->reloc_count == 0)
+      || (sec->flags & SEC_CODE) == 0)
     return TRUE;
 
   BFD_ASSERT ((sec->size > 0) || (sec->rawsize > 0));
@@ -1338,6 +1817,7 @@ microblaze_elf_relax_section (bfd *abfd,
 
   irelend = internal_relocs + sec->reloc_count;
   rel_count = 0;
+  D(fprintf (stderr, "%s:%s\n", abfd->filename, sec->name));
   for (irel = internal_relocs; irel < irelend; irel++, rel_count++)
     {
       bfd_vma symval;
@@ -1475,17 +1955,26 @@ microblaze_elf_relax_section (bfd *abfd,
 	        }
 	      break;
 	    case R_MICROBLAZE_NONE:
+	    case R_MICROBLAZE_32_NONE:
 	      {
 	        /* This was a PC-relative instruction that was
  		   completely resolved.  */
 	        int sfix, efix;
+		unsigned int val;
 	        bfd_vma target_address;
 	        target_address = irel->r_addend + irel->r_offset;
 	        sfix = calc_fixup (irel->r_offset, sec);
 	        efix = calc_fixup (target_address, sec);
+
+                /* Validate the in-band val.  */
+                val = bfd_get_32 (abfd, contents + irel->r_offset);
+                if (val != irel->r_addend && ELF32_R_TYPE (irel->r_info) == R_MICROBLAZE_32_NONE) {
+                    fprintf(stderr, "%d: CORRUPT relax reloc %x %lx\n", __LINE__, val, irel->r_addend);
+                }
 	        irel->r_addend -= (efix - sfix);
 	        /* Should use HOWTO.  */
-	        bfd_put_16 (abfd, irel->r_addend, contents + irel->r_offset + 2);
+                microblaze_bfd_write_imm_value_32 (abfd, contents + irel->r_offset,
+                                                   irel->r_addend);
 	      }
 	      break;
 	    case R_MICROBLAZE_64_NONE:
@@ -1498,8 +1987,9 @@ microblaze_elf_relax_section (bfd *abfd,
 		sfix = calc_fixup (irel->r_offset + INST_WORD_SIZE, sec);
 		efix = calc_fixup (target_address, sec);
 		irel->r_addend -= (efix - sfix);
-		bfd_put_16 (abfd, irel->r_addend, contents + irel->r_offset
-			    + INST_WORD_SIZE + 2);
+                microblaze_bfd_write_imm_value_32 (abfd,
+                                               contents + irel->r_offset + INST_WORD_SIZE,
+                                               irel->r_addend);
 	      }
 	      break;
 	    }
@@ -1529,6 +2019,49 @@ microblaze_elf_relax_section (bfd *abfd,
           irelscanend = irelocs + o->reloc_count;
           for (irelscan = irelocs; irelscan < irelscanend; irelscan++)
             {
+              if (1 && ELF32_R_TYPE (irelscan->r_info) == (int) R_MICROBLAZE_32_NONE)
+                {
+                  unsigned int val;
+
+                  isym = isymbuf + ELF32_R_SYM (irelscan->r_info);
+
+                  /* hax: We only do the following fixup for debug location lists.  */
+                  if (strcmp(".debug_loc", o->name))
+                    continue;
+
+                  /* This was a PC-relative instruction that was completely resolved.  */
+                  if (ocontents == NULL)
+                    {
+		      if (elf_section_data (o)->this_hdr.contents != NULL)
+		          ocontents = elf_section_data (o)->this_hdr.contents;
+		      else
+		        {
+		          /* We always cache the section contents.
+			     Perhaps, if info->keep_memory is FALSE, we
+			     should free them, if we are permitted to.  */
+
+		          if (o->rawsize == 0)
+			      o->rawsize = o->size;
+		          ocontents = (bfd_byte *) bfd_malloc (o->rawsize);
+		          if (ocontents == NULL)
+			      goto error_return;
+		          if (!bfd_get_section_contents (abfd, o, ocontents,
+                                                         (file_ptr) 0,
+                                                         o->rawsize))
+                              goto error_return;
+		          elf_section_data (o)->this_hdr.contents = ocontents;
+		        }
+		    }
+
+                  val = bfd_get_32 (abfd, ocontents + irelscan->r_offset);
+                  if (val != irelscan->r_addend) {
+			fprintf(stderr, "%d: CORRUPT relax reloc! %x %lx\n", __LINE__, val, irelscan->r_addend);
+                  }
+
+                  irelscan->r_addend -= calc_fixup (irelscan->r_addend, sec);
+                  microblaze_bfd_write_imm_value_32 (abfd, ocontents + irelscan->r_offset,
+                                                     irelscan->r_addend);
+              }
               if (ELF32_R_TYPE (irelscan->r_info) == (int) R_MICROBLAZE_32)
                 {
 	          isym = isymbuf + ELF32_R_SYM (irelscan->r_info);
@@ -1588,7 +2121,7 @@ microblaze_elf_relax_section (bfd *abfd,
 			      elf_section_data (o)->this_hdr.contents = ocontents;
 			    }
 			}
-		      irelscan->r_addend -= calc_fixup (irel->r_addend
+		      irelscan->r_addend -= calc_fixup (irelscan->r_addend
 							+ isym->st_value,
 							sec);
 		    }
@@ -1627,13 +2160,13 @@ microblaze_elf_relax_section (bfd *abfd,
 			    }
 			}
 
-		      immediate = (unsigned short) bfd_get_16 (abfd, ocontents +
-							       irelscan->r_offset + 2);
+                      unsigned long instr = bfd_get_32 (abfd, ocontents + irelscan->r_offset);
+                      immediate = instr & 0x0000ffff;
 		      target_address = immediate;
 		      offset = calc_fixup (target_address, sec);
 		      immediate -= offset;
 		      irelscan->r_addend -= offset;
-		      bfd_put_16 (abfd, immediate, ocontents + irelscan->r_offset + 2);
+                      microblaze_bfd_write_imm_value_32 (abfd, ocontents + irelscan->r_offset, irelscan->r_addend);
 		    }
 		}
 
@@ -1669,15 +2202,10 @@ microblaze_elf_relax_section (bfd *abfd,
 			      elf_section_data (o)->this_hdr.contents = ocontents;
 			    }
 			}
-		      immediate = (unsigned short) (bfd_get_16 (abfd, ocontents
-								+ irelscan->r_offset
-								+ 2) << 16)
-			& 0xffff0000;
-		      immediate += (unsigned short) (bfd_get_16 (abfd, ocontents
-								 + irelscan->r_offset
-								 + INST_WORD_SIZE + 2))
-			& 0x0000ffff;
-
+                      unsigned long instr_hi =  bfd_get_32 (abfd, ocontents + irelscan->r_offset);
+                      unsigned long instr_lo =  bfd_get_32 (abfd, ocontents + irelscan->r_offset + INST_WORD_SIZE);
+                      immediate = (instr_hi & 0x0000ffff) << 16;
+                      immediate |= (instr_lo & 0x0000ffff);
 		      offset = calc_fixup (irelscan->r_addend, sec);
 		      immediate -= offset;
 		      irelscan->r_addend -= offset;
@@ -1715,22 +2243,15 @@ microblaze_elf_relax_section (bfd *abfd,
 			      elf_section_data (o)->this_hdr.contents = ocontents;
 			    }
 			}
-
-		      immediate = (unsigned short)
-			(bfd_get_16 (abfd, ocontents + irelscan->r_offset + 2) << 16)
-			& 0xffff0000;
-		      immediate += (unsigned short)
-			(bfd_get_16 (abfd, ocontents + irelscan->r_offset
-				     + INST_WORD_SIZE + 2))
-			& 0x0000ffff;
+                      unsigned long instr_hi =  bfd_get_32 (abfd, ocontents + irelscan->r_offset);
+                      unsigned long instr_lo =  bfd_get_32 (abfd, ocontents + irelscan->r_offset + INST_WORD_SIZE);
+                      immediate = (instr_hi & 0x0000ffff) << 16;
+                      immediate |= (instr_lo & 0x0000ffff);
 		      target_address = immediate;
 		      offset = calc_fixup (target_address, sec);
 		      immediate -= offset;
 		      irelscan->r_addend -= offset;
-		      bfd_put_16 (abfd, ((immediate >> 16) & 0x0000ffff),
-				  ocontents + irelscan->r_offset + 2);
-		      bfd_put_16 (abfd, (immediate & 0x0000ffff),
-				  ocontents + irelscan->r_offset + INST_WORD_SIZE + 2);
+                      microblaze_bfd_write_imm_value_64 (abfd, ocontents + irelscan->r_offset, immediate);
 		    }
 		}
             }
@@ -1740,23 +2261,38 @@ microblaze_elf_relax_section (bfd *abfd,
       isymend = isymbuf + symtab_hdr->sh_info;
       for (isym = isymbuf; isym < isymend; isym++)
         {
-          if (isym->st_shndx == shndx)
-	    isym->st_value =- calc_fixup (isym->st_value, sec);
+          if (isym->st_shndx == shndx) {
+            int count, count_size;
+
+            count = calc_fixup (isym->st_value, sec);
+            count_size = calc_size_fixup (isym->st_value, isym->st_size, sec);
+            D(fprintf(stderr, "local adjust loc=%x.%d size=%d.%d \n",
+			isym->st_value, -count,
+			isym->st_size, -count_size));
+            isym->st_value -= count;
+            isym->st_size -= count_size;
+          }
         }
 
       /* Now adjust the global symbols defined in this section.  */
       isym = isymbuf + symtab_hdr->sh_info;
-      isymend = isymbuf + (symtab_hdr->sh_size / sizeof (Elf32_External_Sym));
-      for (sym_index = 0; isym < isymend; isym++, sym_index++)
+      symcount =  (symtab_hdr->sh_size / sizeof (Elf32_External_Sym)) - symtab_hdr->sh_info;
+      for (sym_index = 0; sym_index < symcount; sym_index++)
         {
           sym_hash = elf_sym_hashes (abfd)[sym_index];
-          if (isym->st_shndx == shndx
-              && (sym_hash->root.type == bfd_link_hash_defined
+          if ((sym_hash->root.type == bfd_link_hash_defined
                   || sym_hash->root.type == bfd_link_hash_defweak)
               && sym_hash->root.u.def.section == sec)
 	    {
-	      sym_hash->root.u.def.value -= calc_fixup (sym_hash->root.u.def.value,
-						        sec);
+              int count, count_size;
+
+              count = calc_fixup (sym_hash->root.u.def.value, sec);
+              count_size = calc_size_fixup (sym_hash->root.u.def.value, sym_hash->size, sec);
+              D(fprintf(stderr, "adjust loc=%x.%d size=%d.%d \n",
+			sym_hash->root.u.def.value, -count,
+			 sym_hash->size, -count_size));
+              sym_hash->root.u.def.value -= count;
+              sym_hash->size -= count_size;
 	    }
 	}
 
@@ -1771,6 +2307,8 @@ microblaze_elf_relax_section (bfd *abfd,
           memmove (contents + dest, contents + src, len);
           sec->size -= sec->relax[i].size;
           dest += len;
+          D(fprintf(stderr, "relax %x to %x relaxsize=%d secsize=%d\n",
+		src, dest, sec->relax[i].size, sec->size));
         }
 
       elf_section_data (sec)->relocs = internal_relocs;
@@ -1800,9 +2338,12 @@ microblaze_elf_relax_section (bfd *abfd,
 
   if (sec->relax_count == 0)
     {
+      *again = FALSE;
       free (sec->relax);
       sec->relax = NULL;
     }
+  else
+    *again = TRUE;
   return TRUE;
 
  error_return:
@@ -1880,7 +2421,7 @@ create_got_section (bfd *dynobj, struct 
   if (!htab->sgot || !htab->sgotplt)
     return FALSE;
 
-  htab->srelgot = bfd_make_section (dynobj, ".rela.got");
+  htab->srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
   if (htab->srelgot == NULL
       || ! bfd_set_section_flags (dynobj, htab->srelgot, SEC_ALLOC
                                   | SEC_LOAD
@@ -1893,6 +2434,34 @@ create_got_section (bfd *dynobj, struct 
   return TRUE;
 }
 
+static bfd_boolean
+update_local_sym_info (bfd *abfd,
+		       Elf_Internal_Shdr *symtab_hdr,
+		       unsigned long r_symndx,
+		       unsigned int tls_type)
+{
+  bfd_signed_vma *local_got_refcounts = elf_local_got_refcounts (abfd);
+  unsigned char *local_got_tls_masks;
+
+  if (local_got_refcounts == NULL)
+    {
+      bfd_size_type size = symtab_hdr->sh_info;
+
+      size *= (sizeof (*local_got_refcounts)
+	       + sizeof (*local_got_tls_masks));
+      local_got_refcounts = bfd_zalloc (abfd, size);
+      if (local_got_refcounts == NULL)
+	return FALSE;
+      elf_local_got_refcounts (abfd) = local_got_refcounts;
+    }
+
+  local_got_tls_masks = 
+         (unsigned char *) (local_got_refcounts + symtab_hdr->sh_info);
+  local_got_tls_masks[r_symndx] |= tls_type;
+  local_got_refcounts[r_symndx] += 1;
+
+  return TRUE;
+}
 /* Look through the relocs for a section during the first phase.  */
 
 static bfd_boolean
@@ -1929,6 +2498,7 @@ microblaze_elf_check_relocs (bfd * abfd,
       unsigned int r_type;
       struct elf_link_hash_entry * h;
       unsigned long r_symndx;
+      unsigned char tls_type = 0;
 
       r_symndx = ELF32_R_SYM (rel->r_info);
       r_type = ELF32_R_TYPE (rel->r_info);
@@ -1964,6 +2534,13 @@ microblaze_elf_check_relocs (bfd * abfd,
           break;
 
 	  /* This relocation requires .got entry.  */
+        case R_MICROBLAZE_TLSGD:
+		tls_type |= (TLS_TLS | TLS_GD);	
+		goto dogottls;
+        case R_MICROBLAZE_TLSLD:
+		tls_type |= (TLS_TLS | TLS_LD);	
+	dogottls:
+	  sec->has_tls_reloc = 1;
         case R_MICROBLAZE_GOT_64:
           if (htab->sgot == NULL)
             {
@@ -1975,25 +2552,12 @@ microblaze_elf_check_relocs (bfd * abfd,
           if (h != NULL)
 	    {
 	      h->got.refcount += 1;
+	      elf32_mb_hash_entry (h)->tls_mask |= tls_type;
 	    }
           else
 	    {
-	      bfd_signed_vma *local_got_refcounts;
-
-	      /* This is a global offset table entry for a local symbol.  */
-	      local_got_refcounts = elf_local_got_refcounts (abfd);
-	      if (local_got_refcounts == NULL)
-		{
-		  bfd_size_type size;
-
-		  size = symtab_hdr->sh_info;
-		  size *= sizeof (bfd_signed_vma);
-		  local_got_refcounts = bfd_zalloc (abfd, size);
-		  if (local_got_refcounts == NULL)
-		    return FALSE;
-		  elf_local_got_refcounts (abfd) = local_got_refcounts;
-		}
-	      local_got_refcounts[r_symndx] += 1;
+              if (! update_local_sym_info(abfd, symtab_hdr, r_symndx, tls_type) )
+		return FALSE;
 	    }
           break;
 
@@ -2006,7 +2570,7 @@ microblaze_elf_check_relocs (bfd * abfd,
 		/* we may need a copy reloc.  */
 		h->non_got_ref = 1;
 
-		/* we may also need a .plt entry.  */
+	        /* we may also need a .plt entry.  */
 		h->plt.refcount += 1;
 		if (ELF32_R_TYPE (rel->r_info) != R_MICROBLAZE_64_PCREL)
 		  h->pointer_equality_needed = 1;
@@ -2057,44 +2621,17 @@ microblaze_elf_check_relocs (bfd * abfd,
 
 		if (sreloc == NULL)
 		  {
-		    const char *name;
 		    bfd *dynobj;
-		    unsigned int strndx = elf_elfheader (abfd)->e_shstrndx;
-		    unsigned int shnam = _bfd_elf_single_rel_hdr (sec)->sh_name;
-
-		    name = bfd_elf_string_from_elf_section (abfd, strndx, shnam);
-		    if (name == NULL)
-		      return FALSE;
-
-		    if (strncmp (name, ".rela", 5) != 0
-			|| strcmp (bfd_get_section_name (abfd, sec),
-				   name + 5) != 0)
-		      {
-			(*_bfd_error_handler)
-			  (_("%B: bad relocation section name `%s\'"),
-			   abfd, name);
-		      }
 
 		    if (htab->elf.dynobj == NULL)
 		      htab->elf.dynobj = abfd;
+
 		    dynobj = htab->elf.dynobj;
 
-		    sreloc = bfd_get_section_by_name (dynobj, name);
+	            sreloc = _bfd_elf_make_dynamic_reloc_section
+		                     (sec, dynobj, 2, abfd, 1);
 		    if (sreloc == NULL)
-		      {
-			flagword flags;
-
-			sreloc = bfd_make_section (dynobj, name);
-			flags = (SEC_HAS_CONTENTS | SEC_READONLY
-				 | SEC_IN_MEMORY | SEC_LINKER_CREATED);
-			if ((sec->flags & SEC_ALLOC) != 0)
-			  flags |= SEC_ALLOC | SEC_LOAD;
-			if (sreloc == NULL
-			    || ! bfd_set_section_flags (dynobj, sreloc, flags)
-			    || ! bfd_set_section_alignment (dynobj, sreloc, 2))
-			  return FALSE;
-		      }
-		    elf_section_data (sec)->sreloc = sreloc;
+		      return FALSE;
 		  }
 
 		/* If this is a global symbol, we count the number of
@@ -2225,6 +2762,8 @@ microblaze_elf_copy_indirect_symbol (str
       eind->dyn_relocs = NULL;
     }
 
+   edir->tls_mask |= eind->tls_mask;
+
   _bfd_elf_link_hash_copy_indirect (info, dir, ind);
 }
 
@@ -2443,8 +2982,10 @@ allocate_dynrelocs (struct elf_link_hash
       h->needs_plt = 0;
     }
 
+  eh = (struct elf32_mb_link_hash_entry *) h;
   if (h->got.refcount > 0)
     {
+      unsigned int need;
       asection *s;
 
       /* Make sure this symbol is output as a dynamic symbol.
@@ -2455,16 +2996,43 @@ allocate_dynrelocs (struct elf_link_hash
           if (! bfd_elf_link_record_dynamic_symbol (info, h))
             return FALSE;
         }
-
-      s = htab->sgot;
-      h->got.offset = s->size;
-      s->size += 4;
-      htab->srelgot->size += sizeof (Elf32_External_Rela);
+      need = 0;
+      if ((eh->tls_mask & TLS_TLS) != 0)
+	{
+          /* Handle TLS Symbol */ 
+	  if ((eh->tls_mask & TLS_LD) != 0)
+	    {
+	      if (!eh->elf.def_dynamic)
+		/* We'll just use htab->tlsld_got.offset.  This should
+		   always be the case.  It's a little odd if we have
+		   a local dynamic reloc against a non-local symbol.  */
+		htab->tlsld_got.refcount += 1;
+	      else
+		need += 8;
+	    }
+	  if ((eh->tls_mask & TLS_GD) != 0)
+	    need += 8;
+	}
+      else 
+	{
+          /* Regular (non-TLS) symbol */
+	  need += 4;
+	}
+      if (need == 0)
+        {
+          h->got.offset = (bfd_vma) -1;
+        }
+      else 
+        {
+          s = htab->sgot;
+          h->got.offset = s->size;
+          s->size += need;
+          htab->srelgot->size += need * (sizeof (Elf32_External_Rela) / 4);
+        }
     }
   else
     h->got.offset = (bfd_vma) -1;
 
-  eh = (struct elf32_mb_link_hash_entry *) h;
   if (eh->dyn_relocs == NULL)
     return TRUE;
 
@@ -2562,6 +3130,7 @@ microblaze_elf_size_dynamic_sections (bf
       bfd_signed_vma *end_local_got;
       bfd_size_type locsymcount;
       Elf_Internal_Shdr *symtab_hdr;
+      unsigned char *lgot_masks;
       asection *srel;
 
       if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour)
@@ -2601,17 +3170,36 @@ microblaze_elf_size_dynamic_sections (bf
       symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
       locsymcount = symtab_hdr->sh_info;
       end_local_got = local_got + locsymcount;
+      lgot_masks = (unsigned char *) end_local_got;
       s = htab->sgot;
       srel = htab->srelgot;
 
-      for (; local_got < end_local_got; ++local_got)
+      for (; local_got < end_local_got; ++local_got, ++lgot_masks)
         {
           if (*local_got > 0)
             {
-              *local_got = s->size;
-              s->size += 4;
-              if (info->shared)
-                srel->size += sizeof (Elf32_External_Rela);
+	      unsigned int need = 0;
+	      if ((*lgot_masks & TLS_TLS) != 0)
+	        {
+		  if ((*lgot_masks & TLS_GD) != 0)
+		    need += 8;
+		  if ((*lgot_masks & TLS_LD) != 0)
+		    htab->tlsld_got.refcount += 1;
+	        }
+	      else
+	        need += 4;
+
+              if (need == 0)
+                {
+                  *local_got = (bfd_vma) -1;
+                }
+              else
+                {
+                  *local_got = s->size;
+                  s->size += need;
+                  if (info->shared)
+                    srel->size += need * ( sizeof (Elf32_External_Rela) / 4 );
+                }
             }
           else
             *local_got = (bfd_vma) -1;
@@ -2622,6 +3210,16 @@ microblaze_elf_size_dynamic_sections (bf
      sym dynamic relocs.  */
   elf_link_hash_traverse (elf_hash_table (info), allocate_dynrelocs, info);
 
+  if (htab->tlsld_got.refcount > 0)
+    {
+      htab->tlsld_got.offset = htab->sgot->size;
+      htab->sgot->size += 8;
+      if (info->shared)
+	htab->srelgot->size += sizeof (Elf32_External_Rela);
+    }
+  else
+    htab->tlsld_got.offset = (bfd_vma) -1;
+
   if (elf_hash_table (info)->dynamic_sections_created)
     {
       /* Make space for the trailing nop in .plt.  */
@@ -2740,6 +3338,7 @@ microblaze_elf_finish_dynamic_symbol (bf
 				      Elf_Internal_Sym *sym)
 {
   struct elf32_mb_link_hash_table *htab;
+  struct elf32_mb_link_hash_entry *eh = elf32_mb_hash_entry(h);
 
   htab = elf32_mb_hash_table (info);
   if (htab == NULL)
@@ -2811,12 +3410,14 @@ microblaze_elf_finish_dynamic_symbol (bf
         }
     }
 
-  if (h->got.offset != (bfd_vma) -1)
+  /* h->got.refcount to be checked ? */
+  if (h->got.offset != (bfd_vma) -1 && 
+      ! ((h->got.offset & 1) || 
+        IS_TLS_LD(eh->tls_mask) || IS_TLS_GD(eh->tls_mask)))
     {
       asection *sgot;
       asection *srela;
-      Elf_Internal_Rela rela;
-      bfd_byte *loc;
+      bfd_vma offset;
 
       /* This symbol has an entry in the global offset table.  Set it
          up.  */
@@ -2825,36 +3426,36 @@ microblaze_elf_finish_dynamic_symbol (bf
       srela = htab->srelgot;
       BFD_ASSERT (sgot != NULL && srela != NULL);
 
-      rela.r_offset = (sgot->output_section->vma
-                       + sgot->output_offset
+      offset = (sgot->output_section->vma + sgot->output_offset
                        + (h->got.offset &~ (bfd_vma) 1));
 
-      /* If this is a -Bsymbolic link, and the symbol is defined
-         locally, we just want to emit a RELATIVE reloc.  Likewise if
-         the symbol was forced to be local because of a version file.
-         The entry in the global offset table will already have been
-         initialized in the relocate_section function.  */
-      if (info->shared
-          && (info->symbolic || h->dynindx == -1)
-          && h->def_regular)
-        {
-          asection *sec = h->root.u.def.section;
-          rela.r_info = ELF32_R_INFO (0, R_MICROBLAZE_REL);
-          rela.r_addend = (h->root.u.def.value
-                           + sec->output_section->vma
-                           + sec->output_offset);
-        }
-      else
-        {
-          rela.r_info = ELF32_R_INFO (h->dynindx, R_MICROBLAZE_GLOB_DAT);
-          rela.r_addend = 0;
-        }
+       {
+         /* If this is a -Bsymbolic link, and the symbol is defined
+            locally, we just want to emit a RELATIVE reloc.  Likewise if
+            the symbol was forced to be local because of a version file.
+            The entry in the global offset table will already have been
+            initialized in the relocate_section function.  */
+          if (info->shared && (info->symbolic || h->dynindx == -1)
+            && h->def_regular)
+          {
+            asection *sec = h->root.u.def.section;
+            microblaze_elf_output_dynamic_relocation ( output_bfd, 
+              srela, srela->reloc_count++, /* symindex= */ 0,
+   	      R_MICROBLAZE_REL, offset, 
+              h->root.u.def.value + sec->output_section->vma 
+              + sec->output_offset);
+          }
+        else
+          {
+            microblaze_elf_output_dynamic_relocation ( output_bfd, 
+              srela, srela->reloc_count++,
+	      h->dynindx, R_MICROBLAZE_GLOB_DAT, offset, 0);
+          }
+       }
 
-      bfd_put_32 (output_bfd, (bfd_vma) 0,
+        bfd_put_32 (output_bfd, (bfd_vma) 0,
                   sgot->contents + (h->got.offset &~ (bfd_vma) 1));
-      loc = srela->contents;
-      loc += srela->reloc_count++ * sizeof (Elf32_External_Rela);
-      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
+
     }
 
   if (h->needs_copy)
@@ -3015,6 +3616,8 @@ microblaze_elf_add_symbol_hook (bfd *abf
   return TRUE;
 }
 
+#define TARGET_LITTLE_SYM      bfd_elf32_microblazeel_vec
+#define TARGET_LITTLE_NAME     "elf32-microblazeel"
 
 #define TARGET_BIG_SYM          bfd_elf32_microblaze_vec
 #define TARGET_BIG_NAME		"elf32-microblaze"
@@ -3023,7 +3626,7 @@ microblaze_elf_add_symbol_hook (bfd *abf
 #define ELF_TARGET_ID		MICROBLAZE_ELF_DATA
 #define ELF_MACHINE_CODE	EM_MICROBLAZE
 #define ELF_MACHINE_ALT1	EM_MICROBLAZE_OLD
-#define ELF_MAXPAGESIZE		0x4   		/* 4k, if we ever have 'em.  */
+#define ELF_MAXPAGESIZE		0x1000   		/* 4k, if we ever have 'em.  */
 #define elf_info_to_howto	microblaze_elf_info_to_howto
 #define elf_info_to_howto_rel	NULL
 
@@ -3031,6 +3634,7 @@ microblaze_elf_add_symbol_hook (bfd *abf
 #define bfd_elf32_bfd_is_local_label_name       microblaze_elf_is_local_label_name
 #define elf_backend_relocate_section		microblaze_elf_relocate_section
 #define bfd_elf32_bfd_relax_section             microblaze_elf_relax_section
+#define bfd_elf32_bfd_merge_private_bfd_data    microblaze_elf_merge_private_bfd_data
 #define bfd_elf32_bfd_reloc_name_lookup		microblaze_elf_reloc_name_lookup
 
 #define elf_backend_gc_mark_hook		microblaze_elf_gc_mark_hook
diff -purN --exclude=.gitignore --exclude=.git --exclude=patches binutils-microblaze/bfd/elf32-ppc.c git.xilinx.com_microblaze-gnu_src_binutils/bfd/elf32-ppc.c
--- binutils-microblaze/bfd/elf32-ppc.c	2012-10-07 16:26:11.294350942 +0200
+++ git.xilinx.com_microblaze-gnu_src_binutils/bfd/elf32-ppc.c	2012-09-28 23:25:51.792909463 +0200
@@ -2891,7 +2891,7 @@ ppc_elf_create_glink (bfd *abfd, struct 
 
   flags = (SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_HAS_CONTENTS
 	   | SEC_IN_MEMORY | SEC_LINKER_CREATED);
-  s = bfd_make_section_with_flags (abfd, ".rela.iplt", flags);
+  s = bfd_make_section_anyway_with_flags (abfd, ".rela.iplt", flags);
   htab->reliplt = s;
   if (s == NULL
       || ! bfd_set_section_alignment (abfd, s, 2))
@@ -2924,8 +2924,8 @@ ppc_elf_create_dynamic_sections (bfd *ab
     return FALSE;
 
   htab->dynbss = bfd_get_section_by_name (abfd, ".dynbss");
-  s = bfd_make_section_with_flags (abfd, ".dynsbss",
-				   SEC_ALLOC | SEC_LINKER_CREATED);
+  s = bfd_make_section_anyway_with_flags (abfd, ".dynsbss",
+					  SEC_ALLOC | SEC_LINKER_CREATED);
   htab->dynsbss = s;
   if (s == NULL)
     return FALSE;
@@ -2935,7 +2935,7 @@ ppc_elf_create_dynamic_sections (bfd *ab
       htab->relbss = bfd_get_section_by_name (abfd, ".rela.bss");
       flags = (SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_HAS_CONTENTS
 	       | SEC_IN_MEMORY | SEC_LINKER_CREATED);
-      s = bfd_make_section_with_flags (abfd, ".rela.sbss", flags);
+      s = bfd_make_section_anyway_with_flags (abfd, ".rela.sbss", flags);
       htab->relsbss = s;
       if (s == NULL
 	  || ! bfd_set_section_alignment (abfd, s, 2))
diff -purN --exclude=.gitignore --exclude=.git --exclude=patches binutils-microblaze/bfd/elf-eh-frame.c git.xilinx.com_microblaze-gnu_src_binutils/bfd/elf-eh-frame.c
--- binutils-microblaze/bfd/elf-eh-frame.c	2012-10-07 16:26:10.934067612 +0200
+++ git.xilinx.com_microblaze-gnu_src_binutils/bfd/elf-eh-frame.c	2012-09-28 23:25:51.022846101 +0200
@@ -913,9 +913,12 @@ _bfd_elf_parse_eh_frame (bfd *abfd, stru
   goto success;
 
  free_no_table:
-  (*info->callbacks->einfo)
-    (_("%P: error in %B(%A); no .eh_frame_hdr table will be created.\n"),
-     abfd, sec);
+  /* FIXME: Remove the microblaze specifics when relaxing gets fixed.  */
+  if (bfd_get_arch(abfd) != bfd_arch_microblaze) {
+    (*info->callbacks->einfo)
+      (_("%P: error in %B(%A); no .eh_frame_hdr table will be created.\n"),
+       abfd, sec);
+  }
   hdr_info->table = FALSE;
   if (sec_info)
     free (sec_info);
diff -purN --exclude=.gitignore --exclude=.git --exclude=patches binutils-microblaze/bfd/elflink.c git.xilinx.com_microblaze-gnu_src_binutils/bfd/elflink.c
--- binutils-microblaze/bfd/elflink.c	2012-10-07 16:26:11.534048332 +0200
+++ git.xilinx.com_microblaze-gnu_src_binutils/bfd/elflink.c	2012-09-28 23:25:52.313448451 +0200
@@ -111,17 +111,17 @@ _bfd_elf_create_got_section (bfd *abfd, 
 
   flags = bed->dynamic_sec_flags;
 
-  s = bfd_make_section_with_flags (abfd,
-				   (bed->rela_plts_and_copies_p
-				    ? ".rela.got" : ".rel.got"),
-				   (bed->dynamic_sec_flags
-				    | SEC_READONLY));
+  s = bfd_make_section_anyway_with_flags (abfd,
+					  (bed->rela_plts_and_copies_p
+					   ? ".rela.got" : ".rel.got"),
+					  (bed->dynamic_sec_flags
+					   | SEC_READONLY));
   if (s == NULL
       || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
     return FALSE;
   htab->srelgot = s;
 
-  s = bfd_make_section_with_flags (abfd, ".got", flags);
+  s = bfd_make_section_anyway_with_flags (abfd, ".got", flags);
   if (s == NULL
       || !bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
     return FALSE;
@@ -129,7 +129,7 @@ _bfd_elf_create_got_section (bfd *abfd, 
 
   if (bed->want_got_plt)
     {
-      s = bfd_make_section_with_flags (abfd, ".got.plt", flags);
+      s = bfd_make_section_anyway_with_flags (abfd, ".got.plt", flags);
       if (s == NULL
 	  || !bfd_set_section_alignment (abfd, s,
 					 bed->s->log_file_align))
@@ -207,44 +207,44 @@ _bfd_elf_link_create_dynamic_sections (b
      shared library does not.  */
   if (info->executable)
     {
-      s = bfd_make_section_with_flags (abfd, ".interp",
-				       flags | SEC_READONLY);
+      s = bfd_make_section_anyway_with_flags (abfd, ".interp",
+					      flags | SEC_READONLY);
       if (s == NULL)
 	return FALSE;
     }
 
   /* Create sections to hold version informations.  These are removed
      if they are not needed.  */
-  s = bfd_make_section_with_flags (abfd, ".gnu.version_d",
-				   flags | SEC_READONLY);
+  s = bfd_make_section_anyway_with_flags (abfd, ".gnu.version_d",
+					  flags | SEC_READONLY);
   if (s == NULL
       || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
     return FALSE;
 
-  s = bfd_make_section_with_flags (abfd, ".gnu.version",
-				   flags | SEC_READONLY);
+  s = bfd_make_section_anyway_with_flags (abfd, ".gnu.version",
+					  flags | SEC_READONLY);
   if (s == NULL
       || ! bfd_set_section_alignment (abfd, s, 1))
     return FALSE;
 
-  s = bfd_make_section_with_flags (abfd, ".gnu.version_r",
-				   flags | SEC_READONLY);
+  s = bfd_make_section_anyway_with_flags (abfd, ".gnu.version_r",
+					  flags | SEC_READONLY);
   if (s == NULL
       || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
     return FALSE;
 
-  s = bfd_make_section_with_flags (abfd, ".dynsym",
-				   flags | SEC_READONLY);
+  s = bfd_make_section_anyway_with_flags (abfd, ".dynsym",
+					  flags | SEC_READONLY);
   if (s == NULL
       || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
     return FALSE;
 
-  s = bfd_make_section_with_flags (abfd, ".dynstr",
-				   flags | SEC_READONLY);
+  s = bfd_make_section_anyway_with_flags (abfd, ".dynstr",
+					  flags | SEC_READONLY);
   if (s == NULL)
     return FALSE;
 
-  s = bfd_make_section_with_flags (abfd, ".dynamic", flags);
+  s = bfd_make_section_anyway_with_flags (abfd, ".dynamic", flags);
   if (s == NULL
       || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
     return FALSE;
@@ -260,7 +260,8 @@ _bfd_elf_link_create_dynamic_sections (b
 
   if (info->emit_hash)
     {
-      s = bfd_make_section_with_flags (abfd, ".hash", flags | SEC_READONLY);
+      s = bfd_make_section_anyway_with_flags (abfd, ".hash",
+					      flags | SEC_READONLY);
       if (s == NULL
 	  || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
 	return FALSE;
@@ -269,8 +270,8 @@ _bfd_elf_link_create_dynamic_sections (b
 
   if (info->emit_gnu_hash)
     {
-      s = bfd_make_section_with_flags (abfd, ".gnu.hash",
-				       flags | SEC_READONLY);
+      s = bfd_make_section_anyway_with_flags (abfd, ".gnu.hash",
+					      flags | SEC_READONLY);
       if (s == NULL
 	  || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
 	return FALSE;
@@ -321,7 +322,7 @@ _bfd_elf_create_dynamic_sections (bfd *a
   if (bed->plt_readonly)
     pltflags |= SEC_READONLY;
 
-  s = bfd_make_section_with_flags (abfd, ".plt", pltflags);
+  s = bfd_make_section_anyway_with_flags (abfd, ".plt", pltflags);
   if (s == NULL
       || ! bfd_set_section_alignment (abfd, s, bed->plt_alignment))
     return FALSE;
@@ -338,10 +339,10 @@ _bfd_elf_create_dynamic_sections (bfd *a
 	return FALSE;
     }
 
-  s = bfd_make_section_with_flags (abfd,
-				   (bed->rela_plts_and_copies_p
-				    ? ".rela.plt" : ".rel.plt"),
-				   flags | SEC_READONLY);
+  s = bfd_make_section_anyway_with_flags (abfd,
+					  (bed->rela_plts_and_copies_p
+					   ? ".rela.plt" : ".rel.plt"),
+					  flags | SEC_READONLY);
   if (s == NULL
       || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
     return FALSE;
@@ -358,9 +359,8 @@ _bfd_elf_create_dynamic_sections (bfd *a
 	 image and use a R_*_COPY reloc to tell the dynamic linker to
 	 initialize them at run time.  The linker script puts the .dynbss
 	 section into the .bss section of the final image.  */
-      s = bfd_make_section_with_flags (abfd, ".dynbss",
-				       (SEC_ALLOC
-					| SEC_LINKER_CREATED));
+      s = bfd_make_section_anyway_with_flags (abfd, ".dynbss",
+					      (SEC_ALLOC | SEC_LINKER_CREATED));
       if (s == NULL)
 	return FALSE;
 
@@ -377,10 +377,10 @@ _bfd_elf_create_dynamic_sections (bfd *a
 	 copy relocs.  */
       if (! info->shared)
 	{
-	  s = bfd_make_section_with_flags (abfd,
-					   (bed->rela_plts_and_copies_p
-					    ? ".rela.bss" : ".rel.bss"),
-					   flags | SEC_READONLY);
+	  s = bfd_make_section_anyway_with_flags (abfd,
+						  (bed->rela_plts_and_copies_p
+						   ? ".rela.bss" : ".rel.bss"),
+						  flags | SEC_READONLY);
 	  if (s == NULL
 	      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
 	    return FALSE;
diff -purN --exclude=.gitignore --exclude=.git --exclude=patches binutils-microblaze/bfd/libbfd.h git.xilinx.com_microblaze-gnu_src_binutils/bfd/libbfd.h
--- binutils-microblaze/bfd/libbfd.h	2012-10-07 16:26:11.584736430 +0200
+++ git.xilinx.com_microblaze-gnu_src_binutils/bfd/libbfd.h	2012-09-28 23:25:52.962839164 +0200
@@ -2311,6 +2311,7 @@ static const char *const bfd_reloc_code_
   "BFD_RELOC_MICROBLAZE_32_ROSDA",
   "BFD_RELOC_MICROBLAZE_32_RWSDA",
   "BFD_RELOC_MICROBLAZE_32_SYM_OP_SYM",
+  "BFD_RELOC_MICROBLAZE_32_NONE",
   "BFD_RELOC_MICROBLAZE_64_NONE",
   "BFD_RELOC_MICROBLAZE_64_GOTPC",
   "BFD_RELOC_MICROBLAZE_64_GOT",
@@ -2318,6 +2319,14 @@ static const char *const bfd_reloc_code_
   "BFD_RELOC_MICROBLAZE_64_GOTOFF",
   "BFD_RELOC_MICROBLAZE_32_GOTOFF",
   "BFD_RELOC_MICROBLAZE_COPY",
+  "BFD_RELOC_MICROBLAZE_64_TLS",
+  "BFD_RELOC_MICROBLAZE_64_TLSGD",
+  "BFD_RELOC_MICROBLAZE_64_TLSLD",
+  "BFD_RELOC_MICROBLAZE_32_TLSDTPMOD",
+  "BFD_RELOC_MICROBLAZE_32_TLSDTPREL",
+  "BFD_RELOC_MICROBLAZE_64_TLSDTPREL",
+  "BFD_RELOC_MICROBLAZE_64_TLSGOTTPREL",
+  "BFD_RELOC_MICROBLAZE_64_TLSTPREL",
   "BFD_RELOC_TILEPRO_COPY",
   "BFD_RELOC_TILEPRO_GLOB_DAT",
   "BFD_RELOC_TILEPRO_JMP_SLOT",
diff -purN --exclude=.gitignore --exclude=.git --exclude=patches binutils-microblaze/bfd/reloc.c git.xilinx.com_microblaze-gnu_src_binutils/bfd/reloc.c
--- binutils-microblaze/bfd/reloc.c	2012-10-07 16:26:11.964078898 +0200
+++ git.xilinx.com_microblaze-gnu_src_binutils/bfd/reloc.c	2012-09-28 23:25:53.933434420 +0200
@@ -5577,6 +5577,12 @@ ENUMDOC
   This is a 32 bit reloc for the microblaze to handle 
   expressions of the form "Symbol Op Symbol"
 ENUM
+  BFD_RELOC_MICROBLAZE_32_NONE
+ENUMDOC
+  This is a 32 bit reloc that stores the 32 bit pc relative 
+  value in two words (with an imm instruction).  No relocation is 
+  done here - only used for relaxing
+ENUM
   BFD_RELOC_MICROBLAZE_64_NONE
 ENUMDOC
   This is a 64 bit reloc that stores the 32 bit pc relative 
@@ -5617,6 +5623,45 @@ ENUM
 ENUMDOC
   This is used to tell the dynamic linker to copy the value out of
   the dynamic object into the runtime process image.
+ENUM
+  BFD_RELOC_MICROBLAZE_64_TLS
+ENUMDOC
+  Unused Reloc
+ENUM
+  BFD_RELOC_MICROBLAZE_64_TLSGD
+ENUMDOC
+  This is a 64 bit reloc that stores the 32 bit GOT relative value
+  of the GOT TLS GD info entry in two words (with an imm instruction). The
+  relocation is GOT offset.
+ENUM
+  BFD_RELOC_MICROBLAZE_64_TLSLD
+ENUMDOC
+  This is a 64 bit reloc that stores the 32 bit GOT relative value
+  of the GOT TLS LD info entry in two words (with an imm instruction). The
+  relocation is GOT offset.
+ENUM
+  BFD_RELOC_MICROBLAZE_32_TLSDTPMOD
+ENUMDOC
+  This is a 32 bit reloc that stores the Module ID to GOT(n).
+ENUM
+  BFD_RELOC_MICROBLAZE_32_TLSDTPREL
+ENUMDOC
+  This is a 32 bit reloc that stores TLS offset to GOT(n+1).
+ENUM
+  BFD_RELOC_MICROBLAZE_64_TLSDTPREL
+ENUMDOC
+  This is a 32 bit reloc for storing TLS offset to two words (uses imm 
+  instruction)
+ENUM
+  BFD_RELOC_MICROBLAZE_64_TLSGOTTPREL
+ENUMDOC
+  This is a 64 bit reloc that stores 32-bit thread pointer relative offset
+  to two words (uses imm instruction).
+ENUM
+  BFD_RELOC_MICROBLAZE_64_TLSTPREL
+ENUMDOC
+  This is a 64 bit reloc that stores 32-bit thread pointer relative offset
+  to two words (uses imm instruction).
 
 ENUM
   BFD_RELOC_TILEPRO_COPY
diff -purN --exclude=.gitignore --exclude=.git --exclude=patches binutils-microblaze/bfd/section.c git.xilinx.com_microblaze-gnu_src_binutils/bfd/section.c
--- binutils-microblaze/bfd/section.c	2012-10-07 16:26:11.964078898 +0200
+++ git.xilinx.com_microblaze-gnu_src_binutils/bfd/section.c	2012-09-28 23:25:54.075031448 +0200
@@ -394,6 +394,21 @@ CODE_FRAGMENT
 .  {* Bits used by various backends.  The generic code doesn't touch
 .     these fields.  *}
 .
+.  {* Nonzero if this section has TLS related relocations.  *}
+.  unsigned int has_tls_reloc:1;
+.
+.  {* Nonzero if this section has a call to __tls_get_addr.  *}
+.  unsigned int has_tls_get_addr_call:1;
+.
+.  {* Nonzero if this section has a gp reloc.  *}
+.  unsigned int has_gp_reloc:1;
+.
+.  {* Nonzero if this section needs the relax finalize pass.  *}
+.  unsigned int need_finalize_relax:1;
+.
+.  {* Whether relocations have been processed.  *}
+.  unsigned int reloc_done : 1;
+.
 .  unsigned int sec_flg0:1;
 .  unsigned int sec_flg1:1;
 .  unsigned int sec_flg2:1;
@@ -673,14 +688,17 @@ CODE_FRAGMENT
 .  {* linker_mark, linker_has_input, gc_mark, decompress_status,    *}	\
 .     0,           0,                1,       0,			\
 .									\
-.  {* segment_mark, sec_info_type, use_rela_p,                      *}	\
-.     0,            0,             0,					\
+.  {* segment_mark, sec_info_type, use_rela_p, has_tls_reloc,       *}	\
+.     0,            0,             0,          0,			\
 .									\
+.  {* has_tls_get_addr_call, has_gp_reloc, need_finalize_relax,     *}	\
+.     0,                     0,            0,				\
+.
 .  {* sec_flg0, sec_flg1, sec_flg2, sec_flg3, sec_flg4, sec_flg5,   *}	\
 .     0,        0,        0,        0,        0,        0,		\
 .									\
-.  {* vma, lma, size, rawsize, compressed_size, relax, relax_count, *}	\
-.     0,   0,   0,    0,       0,               0,     0,		\
+.  {* reloc_done, vma, lma, size, rawsize, compressed_size, relax, relax_count, *}	\
+.     0,   0,   0,   0,    0,       0,               0,     0,		\
 .									\
 .  {* output_offset, output_section,              alignment_power,  *}	\
 .     0,             (struct bfd_section *) &SEC, 0,			\
diff -purN --exclude=.gitignore --exclude=.git --exclude=patches binutils-microblaze/bfd/targets.c git.xilinx.com_microblaze-gnu_src_binutils/bfd/targets.c
--- binutils-microblaze/bfd/targets.c	2012-10-07 16:26:12.034091427 +0200
+++ git.xilinx.com_microblaze-gnu_src_binutils/bfd/targets.c	2012-09-28 23:25:54.145202647 +0200
@@ -651,6 +651,7 @@ extern const bfd_target bfd_elf32_mcore_
 extern const bfd_target bfd_elf32_mcore_little_vec;
 extern const bfd_target bfd_elf32_mep_vec;
 extern const bfd_target bfd_elf32_mep_little_vec;
+extern const bfd_target bfd_elf32_microblazeel_vec;
 extern const bfd_target bfd_elf32_microblaze_vec;
 extern const bfd_target bfd_elf32_mn10200_vec;
 extern const bfd_target bfd_elf32_mn10300_vec;
diff -purN --exclude=.gitignore --exclude=.git --exclude=patches binutils-microblaze/binutils/readelf.c git.xilinx.com_microblaze-gnu_src_binutils/binutils/readelf.c
--- binutils-microblaze/binutils/readelf.c	2012-10-07 16:26:12.604082220 +0200
+++ git.xilinx.com_microblaze-gnu_src_binutils/binutils/readelf.c	2012-09-28 23:25:54.443102733 +0200
@@ -10015,6 +10015,10 @@ is_none_reloc (unsigned int reloc_type)
     case EM_XC16X:
     case EM_C166:    /* R_XC16X_NONE.  */
       return reloc_type == 0;
+    case EM_MICROBLAZE:
+      return reloc_type == 30 /* R_MICROBLAZE_32_NONE.  */
+             || reloc_type == 0 /* R_MICROBLAZE_NONE.  */
+             || reloc_type == 9; /* R_MICROBLAZE_64_NONE.  */
     case EM_XTENSA_OLD:
     case EM_XTENSA:
       return (reloc_type == 0      /* R_XTENSA_NONE.  */
diff -purN --exclude=.gitignore --exclude=.git --exclude=patches binutils-microblaze/binutils/testsuite/binutils-all/objdump.exp git.xilinx.com_microblaze-gnu_src_binutils/binutils/testsuite/binutils-all/objdump.exp
--- binutils-microblaze/binutils/testsuite/binutils-all/objdump.exp	2012-10-07 16:26:12.604082220 +0200
+++ git.xilinx.com_microblaze-gnu_src_binutils/binutils/testsuite/binutils-all/objdump.exp	2012-09-28 23:25:55.213800622 +0200
@@ -39,7 +39,7 @@ set cpus_expected [list]
 lappend cpus_expected alpha arc arm cris
 lappend cpus_expected d10v d30v fr30 fr500 fr550 h8 hppa i386 i860 i960 ip2022
 lappend cpus_expected m16c m32c m32r m68hc11 m68hc12 m68k m88k MCore
-lappend cpus_expected mips mn10200 mn10300 ms1 msp ns32k pj powerpc pyramid
+lappend cpus_expected MicroBlaze mips mn10200 mn10300 ms1 msp ns32k pj powerpc pyramid
 lappend cpus_expected romp rs6000 s390 sh sparc
 lappend cpus_expected tahoe tic54x tic80 tms320c30 tms320c4x tms320c54x v850
 lappend cpus_expected vax we32k x86-64 xscale xtensa z8k z8001 z8002
diff -purN --exclude=.gitignore --exclude=.git --exclude=patches binutils-microblaze/config.sub git.xilinx.com_microblaze-gnu_src_binutils/config.sub
--- binutils-microblaze/config.sub	2012-10-07 16:26:12.674689994 +0200
+++ git.xilinx.com_microblaze-gnu_src_binutils/config.sub	2012-09-28 23:25:55.832887284 +0200
@@ -154,7 +154,7 @@ case $os in
 	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
 	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
 	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \
-	-apple | -axis | -knuth | -cray | -microblaze)
+	-apple | -axis | -knuth | -cray | -microblaze*)
 		os=
 		basic_machine=$1
 		;;
@@ -260,7 +260,7 @@ case $basic_machine in
 	| ip2k | iq2000 \
 	| lm32 \
 	| m32c | m32r | m32rle | m68000 | m68k | m88k \
-	| maxq | mb | microblaze | mcore | mep | metag \
+	| maxq | mb | microblaze | microblazeel | mcore | mep | metag \
 	| mips | mipsbe | mipseb | mipsel | mipsle \
 	| mips16 \
 	| mips64 | mips64el \
@@ -370,7 +370,8 @@ case $basic_machine in
 	| lm32-* \
 	| m32c-* | m32r-* | m32rle-* \
 	| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \
-	| m88110-* | m88k-* | maxq-* | mcore-* | metag-* | microblaze-* \
+	| m88110-* | m88k-* | maxq-* | mcore-* | metag-* \
+	| microblaze-* | microblazeel-* \
 	| mips-* | mipsbe-* | mipseb-* | mipsel-* | mipsle-* \
 	| mips16-* \
 	| mips64-* | mips64el-* \
@@ -770,7 +771,7 @@ case $basic_machine in
 		basic_machine=ns32k-utek
 		os=-sysv
 		;;
-	microblaze)
+	microblaze*)
 		basic_machine=microblaze-xilinx
 		;;
 	mingw32)
diff -purN --exclude=.gitignore --exclude=.git --exclude=patches binutils-microblaze/gas/config/tc-microblaze.c git.xilinx.com_microblaze-gnu_src_binutils/gas/config/tc-microblaze.c
--- binutils-microblaze/gas/config/tc-microblaze.c	2012-10-07 16:26:14.234063174 +0200
+++ git.xilinx.com_microblaze-gnu_src_binutils/gas/config/tc-microblaze.c	2012-09-28 23:26:11.242855000 +0200
@@ -35,6 +35,9 @@
 #define streq(a,b) (strcmp (a, b) == 0)
 #endif
 
+#define OPTION_EB (OPTION_MD_BASE + 0)
+#define OPTION_EL (OPTION_MD_BASE + 1)
+
 void microblaze_generate_symbol (char *sym);
 static bfd_boolean check_spl_reg (unsigned *);
 
@@ -78,6 +81,11 @@ const char FLT_CHARS[] = "rRsSfFdDxXpP";
 #define GOT_OFFSET           8
 #define PLT_OFFSET           9
 #define GOTOFF_OFFSET        10
+#define TLSGD_OFFSET         11
+#define TLSLD_OFFSET         12
+#define TLSDTPMOD_OFFSET     13
+#define TLSDTPREL_OFFSET     14
+#define TLSTPREL_OFFSET      15
 
 
 /* Initialize the relax table.  */
@@ -94,6 +102,12 @@ const relax_typeS md_relax_table[] =
   { 0x7fffffff, 0x80000000, INST_WORD_SIZE*2, 0 },  /*  8: GOT_OFFSET.  */
   { 0x7fffffff, 0x80000000, INST_WORD_SIZE*2, 0 },  /*  9: PLT_OFFSET.  */
   { 0x7fffffff, 0x80000000, INST_WORD_SIZE*2, 0 },  /* 10: GOTOFF_OFFSET.  */
+  { 0x7fffffff, 0x80000000, INST_WORD_SIZE*2, 0 },  /* 11: TLSGD_OFFSET.  */
+  { 0x7fffffff, 0x80000000, INST_WORD_SIZE*2, 0 },  /* 12: TLSLD_OFFSET.  */
+  { 0x7fffffff, 0x80000000, INST_WORD_SIZE*1, 0 },  /* 13: TLSDTPMOD_OFFSET.  */
+  { 0x7fffffff, 0x80000000, INST_WORD_SIZE*2, 0 },  /* 14: TLSDTPREL_OFFSET.  */
+  { 0x7fffffff, 0x80000000, INST_WORD_SIZE*2, 0 },  /* 15: TLSGOTTPREL_OFFSET.  */
+  { 0x7fffffff, 0x80000000, INST_WORD_SIZE*2, 0 }  /* 16: TLSTPREL_OFFSET.  */
 };
 
 static struct hash_control * opcode_hash_control;	/* Opcode mnemonics.  */
@@ -528,6 +542,17 @@ parse_reg (char * s, unsigned * reg)
 	}
       return s;
     }
+  /* Stack protection registers.  */
+  else if (strncasecmp (s, "rshr", 4) == 0)
+    {
+      *reg = REG_SHR;
+      return s + 4;
+    }
+  else if (strncasecmp (s, "rslr", 4) == 0)
+    {
+      *reg = REG_SLR;
+      return s + 4;
+    }
   else
     {
       if (TOLOWER (s[0]) == 'r')
@@ -585,9 +610,73 @@ parse_exp (char *s, expressionS *e)
 }
 
 /* Symbol modifiers (@GOT, @PLT, @GOTOFF).  */
+
+#define IMM_NONE    0
 #define IMM_GOT    1
 #define IMM_PLT    2
 #define IMM_GOTOFF 3
+#define IMM_TLSGD 4
+#define IMM_TLSLD 5
+#define IMM_TLSDTPMOD 6
+#define IMM_TLSDTPREL 7
+#define IMM_TLSTPREL 8
+#define IMM_MAX 9
+
+struct imm_type {
+	char *isuffix;	 /* Suffix String */
+	int itype;       /* Suffix Type */
+	int otype;       /* Offset Type */
+};
+
+/* These are NOT in assending order of type, GOTOFF is ahead to make 
+   sure @GOTOFF does not get matched with @GOT  */
+static struct imm_type imm_types[] = {
+	{ "NONE", IMM_NONE , 0 },
+	{ "GOTOFF", IMM_GOTOFF , GOTOFF_OFFSET },
+	{ "GOT", IMM_GOT , GOT_OFFSET },
+	{ "PLT", IMM_PLT , PLT_OFFSET },
+	{ "TLSGD", IMM_TLSGD , TLSGD_OFFSET },
+	{ "TLSLDM", IMM_TLSLD, TLSLD_OFFSET },
+	{ "TLSDTPMOD", IMM_TLSDTPMOD, TLSDTPMOD_OFFSET },
+	{ "TLSDTPREL", IMM_TLSDTPREL, TLSDTPREL_OFFSET },
+	{ "TLSTPREL", IMM_TLSTPREL, TLSTPREL_OFFSET }
+};
+
+static int
+match_imm (const char *s, int *ilen)
+{
+  int i;
+  int slen;
+
+  /* Check for matching suffix */
+  for (i = 1; i < IMM_MAX; i++) {
+        slen = strlen (imm_types[i].isuffix);
+
+	if (strncmp (imm_types[i].isuffix, s, slen) == 0)
+	{
+	        *ilen = slen;	
+		return imm_types[i].itype;
+	}	
+  } /* for */
+  *ilen = 0;
+  return 0;
+}
+
+static int
+get_imm_otype (int itype)
+{
+  int i, otype;
+
+  otype = 0;
+  /* Check for matching itype */
+  for (i = 1; i < IMM_MAX; i++) {
+    if (imm_types[i].itype == itype) {
+      otype = imm_types[i].otype;
+      break;
+    }
+  }
+  return otype;
+}
 
 static symbolS * GOT_symbol;
 
@@ -598,6 +687,9 @@ parse_imm (char * s, expressionS * e, in
 {
   char *new_pointer;
   char *atp;
+  int itype, ilen;
+
+  ilen = 0;
 
   /* Find the start of "@GOT" or "@PLT" suffix (if any) */
   for (atp = s; *atp != '@'; atp++)
@@ -606,25 +698,17 @@ parse_imm (char * s, expressionS * e, in
 
   if (*atp == '@')
     {
-      if (strncmp (atp + 1, "GOTOFF", 5) == 0)
-	{
-	  *atp = 0;
-	  e->X_md = IMM_GOTOFF;
-	}
-      else if (strncmp (atp + 1, "GOT", 3) == 0)
-	{
-	  *atp = 0;
-	  e->X_md = IMM_GOT;
-	}
-      else if (strncmp (atp + 1, "PLT", 3) == 0)
-	{
-	  *atp = 0;
-	  e->X_md = IMM_PLT;
+      itype = match_imm (atp + 1, &ilen);
+      if (itype != 0) 
+        { 
+          *atp = 0;
+          e->X_md = itype;
 	}
       else
 	{
 	  atp = NULL;
 	  e->X_md = 0;
+          ilen = 0;	
 	}
       *atp = 0;
     }
@@ -641,6 +725,11 @@ parse_imm (char * s, expressionS * e, in
 
   new_pointer = parse_exp (s, e);
 
+  if (!GOT_symbol && ! strncmp (s, GOT_SYMBOL_NAME, 20)) 
+    {
+      GOT_symbol = symbol_find_or_make (GOT_SYMBOL_NAME);
+    }
+
   if (e->X_op == O_absent)
     ; /* An error message has already been emitted.  */
   else if ((e->X_op != O_constant && e->X_op != O_symbol) )
@@ -656,9 +745,7 @@ parse_imm (char * s, expressionS * e, in
     {
       *atp = '@'; /* restore back (needed?)  */
       if (new_pointer >= atp)
-        new_pointer += (e->X_md == IMM_GOTOFF)?7:4;
-      /* sizeof("@GOTOFF", "@GOT" or "@PLT") */
-
+        new_pointer += ilen + 1; /* sizeof (imm_suffix) + 1 for '@' */
     }
   return new_pointer;
 }
@@ -757,6 +844,7 @@ check_spl_reg (unsigned * reg)
       || (*reg == REG_PID)   || (*reg == REG_ZPR)
       || (*reg == REG_TLBX)  || (*reg == REG_TLBLO)
       || (*reg == REG_TLBHI) || (*reg == REG_TLBSX)
+      || (*reg == REG_SHR)   || (*reg == REG_SLR)
       || (*reg >= REG_PVR+MIN_PVR_REGNUM && *reg <= REG_PVR+MAX_PVR_REGNUM))
     return TRUE;
 
@@ -777,7 +865,14 @@ tc_microblaze_fix_adjustable (struct fix
   if (fixP->fx_r_type == BFD_RELOC_MICROBLAZE_64_GOTOFF
       || fixP->fx_r_type == BFD_RELOC_MICROBLAZE_32_GOTOFF
       || fixP->fx_r_type == BFD_RELOC_MICROBLAZE_64_GOT
-      || fixP->fx_r_type == BFD_RELOC_MICROBLAZE_64_PLT)
+      || fixP->fx_r_type == BFD_RELOC_MICROBLAZE_64_PLT 
+      || fixP->fx_r_type == BFD_RELOC_MICROBLAZE_64_TLSGD
+      || fixP->fx_r_type == BFD_RELOC_MICROBLAZE_64_TLSLD
+      || fixP->fx_r_type == BFD_RELOC_MICROBLAZE_32_TLSDTPMOD
+      || fixP->fx_r_type == BFD_RELOC_MICROBLAZE_32_TLSDTPREL
+      || fixP->fx_r_type == BFD_RELOC_MICROBLAZE_64_TLSDTPREL
+      || fixP->fx_r_type == BFD_RELOC_MICROBLAZE_64_TLSGOTTPREL
+      || fixP->fx_r_type == BFD_RELOC_MICROBLAZE_64_TLSTPREL)
     return 0;
 
   return 1;
@@ -925,15 +1020,12 @@ md_assemble (char * str)
 	    opc = str_microblaze_rw_anchor;
 	  else
 	    opc = NULL;
-	  if (exp.X_md == IMM_GOT)
-	    subtype = GOT_OFFSET;
-	  else if (exp.X_md == IMM_PLT)
-	    subtype = PLT_OFFSET;
-	  else if (exp.X_md == IMM_GOTOFF)
-	    subtype = GOTOFF_OFFSET;
-	  else
-	    subtype = opcode->inst_offset_type;
 
+          if (exp.X_md != 0) {
+             subtype = get_imm_otype(exp.X_md);
+          } else {
+	    subtype = opcode->inst_offset_type;
+          }
 	  output = frag_var (rs_machine_dependent,
 			     isize * 2, /* maxm of 2 words.  */
 			     isize,     /* minm of 1 word.  */
@@ -1198,9 +1290,6 @@ md_assemble (char * str)
           as_fatal (_("Error in statement syntax"));
           immed = 0;
         }
-      /* Check for spl registers.  */
-      if (check_spl_reg (&reg1))
-        as_fatal (_("Cannot use special register with this instruction"));
       inst |= (immed << IMM_LOW) & RFSL_MASK;
       output = frag_more (isize);
       break;
@@ -1280,6 +1369,10 @@ md_assemble (char * str)
         immed = opcode->immval_mask | REG_TLBLO_MASK;
       else if (reg2 == REG_TLBHI)
         immed = opcode->immval_mask | REG_TLBHI_MASK;
+      else if (reg2 == REG_SHR)
+        immed = opcode->immval_mask | REG_SHR_MASK;
+      else if (reg2 == REG_SLR)
+        immed = opcode->immval_mask | REG_SLR_MASK;
       else if (reg2 >= (REG_PVR+MIN_PVR_REGNUM) && reg2 <= (REG_PVR+MAX_PVR_REGNUM))
 	immed = opcode->immval_mask | REG_PVR_MASK | reg2;
       else
@@ -1331,6 +1424,10 @@ md_assemble (char * str)
         immed = opcode->immval_mask | REG_TLBHI_MASK;
       else if (reg1 == REG_TLBSX)
         immed = opcode->immval_mask | REG_TLBSX_MASK;
+      else if (reg1 == REG_SHR)
+        immed = opcode->immval_mask | REG_SHR_MASK;
+      else if (reg1 == REG_SLR)
+        immed = opcode->immval_mask | REG_SLR_MASK;
       else
         as_fatal (_("invalid value for special purpose register"));
       inst |= (reg2 << RA_LOW) & RA_MASK;
@@ -1338,16 +1435,16 @@ md_assemble (char * str)
       output = frag_more (isize);
       break;
 
-    case INST_TYPE_RD_R1_SPECIAL:
+    case INST_TYPE_R1_R2_SPECIAL:
       if (strcmp (op_end, ""))
-        op_end = parse_reg (op_end + 1, &reg1);  /* Get rd.  */
+        op_end = parse_reg (op_end + 1, &reg1);  /* Get r1.  */
       else
 	{
           as_fatal (_("Error in statement syntax"));
           reg1 = 0;
         }
       if (strcmp (op_end, ""))
-        op_end = parse_reg (op_end + 1, &reg2);  /* Get r1.  */
+        op_end = parse_reg (op_end + 1, &reg2);  /* Get r2.  */
       else
 	{
           as_fatal (_("Error in statement syntax"));
@@ -1361,7 +1458,6 @@ md_assemble (char * str)
         as_fatal (_("Cannot use special register with this instruction"));
 
       /* insn wic ra, rb => wic ra, ra, rb.  */
-      inst |= (reg1 << RD_LOW) & RD_MASK;
       inst |= (reg1 << RA_LOW) & RA_MASK;
       inst |= (reg2 << RB_LOW) & RB_MASK;
 
@@ -1417,12 +1513,11 @@ md_assemble (char * str)
           char *opc = NULL;
           relax_substateT subtype;
 
-	  if (exp.X_md == IMM_GOT)
-	    subtype = GOT_OFFSET;
-	  else if (exp.X_md == IMM_PLT)
-	    subtype = PLT_OFFSET;
-	  else
+          if (exp.X_md != 0) {
+             subtype = get_imm_otype(exp.X_md);
+          } else {
 	    subtype = opcode->inst_offset_type;
+          }
 	  output = frag_var (rs_machine_dependent,
 			     isize * 2, /* maxm of 2 words.  */
 			     isize,     /* minm of 1 word.  */
@@ -1484,12 +1579,11 @@ md_assemble (char * str)
           char *opc = NULL;
           relax_substateT subtype;
 
-          if (exp.X_md == IMM_GOT)
-            subtype = GOT_OFFSET;
-          else if (exp.X_md == IMM_PLT)
-            subtype = PLT_OFFSET;
-          else
+          if (exp.X_md != 0) {
+             subtype = get_imm_otype(exp.X_md);
+          } else {
 	    subtype = opcode->inst_offset_type;
+          }
           output = frag_var (rs_machine_dependent,
 			     isize * 2, /* maxm of 2 words.  */
 			     isize,     /* minm of 1 word.  */
@@ -1557,12 +1651,11 @@ md_assemble (char * str)
           char *opc = NULL;
           relax_substateT subtype;
 
-          if (exp.X_md == IMM_GOT)
-            subtype = GOT_OFFSET;
-          else if (exp.X_md == IMM_PLT)
-            subtype = PLT_OFFSET;
-          else
-            subtype = opcode->inst_offset_type;
+          if (exp.X_md != 0) {
+             subtype = get_imm_otype(exp.X_md);
+          } else {
+	    subtype = opcode->inst_offset_type;
+          }
           output = frag_var (rs_machine_dependent,
 			     isize * 2, /* maxm of 2 words.  */
 			     isize,     /* minm of 1 word.  */
@@ -1605,6 +1698,24 @@ md_assemble (char * str)
       output = frag_more (isize);
       break;
 
+    case INST_TYPE_IMM5:
+      if (strcmp(op_end, ""))
+        op_end = parse_imm (op_end + 1, & exp, MIN_IMM5, MAX_IMM5);
+      else
+        as_fatal(_("Error in statement syntax"));
+      if (exp.X_op != O_constant) {
+        as_warn(_("Symbol used as immediate for mbar instruction"));
+      } else {
+        output = frag_more (isize);
+        immed = exp.X_add_number;
+      }
+      if (immed != (immed % 32)) {
+        as_warn(_("Immediate value for mbar > 32. using <value %% 32>"));
+        immed = immed % 32;
+      }
+      inst |= (immed << IMM_MBAR);
+      break;
+
     default:
       as_fatal (_("unimplemented opcode \"%s\""), name);
     }
@@ -1710,6 +1821,8 @@ const char * md_shortopts = "";
 
 struct option md_longopts[] =
 {
+  {"EB", no_argument, NULL, OPTION_EB},
+  {"EL", no_argument, NULL, OPTION_EL},
   { NULL,          no_argument, NULL, 0}
 };
 
@@ -1808,6 +1921,24 @@ md_convert_frag (bfd * abfd ATTRIBUTE_UN
       fragP->fr_fix += INST_WORD_SIZE * 2;
       fragP->fr_var = 0;
       break;
+    case TLSGD_OFFSET:
+      fix_new (fragP, fragP->fr_fix, INST_WORD_SIZE * 2, fragP->fr_symbol,
+	       fragP->fr_offset, FALSE, BFD_RELOC_MICROBLAZE_64_TLSGD);
+      fragP->fr_fix += INST_WORD_SIZE * 2;
+      fragP->fr_var = 0;
+      break;
+    case TLSLD_OFFSET:
+      fix_new (fragP, fragP->fr_fix, INST_WORD_SIZE * 2, fragP->fr_symbol,
+	       fragP->fr_offset, FALSE, BFD_RELOC_MICROBLAZE_64_TLSLD);
+      fragP->fr_fix += INST_WORD_SIZE * 2;
+      fragP->fr_var = 0;
+      break;
+    case TLSDTPREL_OFFSET:
+      fix_new (fragP, fragP->fr_fix, INST_WORD_SIZE * 2, fragP->fr_symbol,
+	       fragP->fr_offset, FALSE, BFD_RELOC_MICROBLAZE_64_TLSDTPREL);
+      fragP->fr_fix += INST_WORD_SIZE * 2;
+      fragP->fr_var = 0;
+      break;
 
     default:
       abort ();
@@ -1989,6 +2120,11 @@ md_apply_fix (fixS *   fixP,
 	}
       break;
 
+    case BFD_RELOC_MICROBLAZE_64_TLSDTPREL:
+    case BFD_RELOC_MICROBLAZE_64_TLSGD:
+    case BFD_RELOC_MICROBLAZE_64_TLSLD:
+      S_SET_THREAD_LOCAL (fixP->fx_addsy);
+
     case BFD_RELOC_MICROBLAZE_64_GOTPC:
     case BFD_RELOC_MICROBLAZE_64_GOT:
     case BFD_RELOC_MICROBLAZE_64_PLT:
@@ -2025,9 +2161,12 @@ md_apply_fix (fixS *   fixP,
 	 moves code around due to relaxing.  */
       if (fixP->fx_r_type == BFD_RELOC_64_PCREL)
 	fixP->fx_r_type = BFD_RELOC_MICROBLAZE_64_NONE;
+      else if (fixP->fx_r_type == BFD_RELOC_32)
+	fixP->fx_r_type = BFD_RELOC_MICROBLAZE_32_NONE;
       else
 	fixP->fx_r_type = BFD_RELOC_NONE;
       fixP->fx_addsy = section_symbol (absolute_section);
+      fixP->fx_done = 0;
     }
   return;
 }
@@ -2065,7 +2204,8 @@ md_estimate_size_before_relax (fragS * f
           as_bad (_("Absolute PC-relative value in relaxation code.  Assembler error....."));
           abort ();
         }
-      else if ((S_GET_SEGMENT (fragP->fr_symbol) == segment_type))
+      else if (S_GET_SEGMENT (fragP->fr_symbol) == segment_type &&
+               !S_IS_WEAK (fragP->fr_symbol))
         {
           fragP->fr_subtype = DEFINED_PC_OFFSET;
           /* Don't know now whether we need an imm instruction.  */
@@ -2166,11 +2306,16 @@ md_estimate_size_before_relax (fragS * f
     case GOT_OFFSET:
     case PLT_OFFSET:
     case GOTOFF_OFFSET:
+    case TLSGD_OFFSET:
+    case TLSLD_OFFSET:
+    case TLSTPREL_OFFSET:
+    case TLSDTPREL_OFFSET:
       fragP->fr_var = INST_WORD_SIZE*2;
       break;
     case DEFINED_RO_SEGMENT:
     case DEFINED_RW_SEGMENT:
     case DEFINED_PC_OFFSET:
+    case TLSDTPMOD_OFFSET:
       fragP->fr_var = INST_WORD_SIZE;
       break;
     default:
@@ -2239,6 +2384,7 @@ tc_gen_reloc (asection * section ATTRIBU
   switch (fixp->fx_r_type)
     {
     case BFD_RELOC_NONE:
+    case BFD_RELOC_MICROBLAZE_32_NONE:
     case BFD_RELOC_MICROBLAZE_64_NONE:
     case BFD_RELOC_32:
     case BFD_RELOC_MICROBLAZE_32_LO:
@@ -2254,6 +2400,13 @@ tc_gen_reloc (asection * section ATTRIBU
     case BFD_RELOC_MICROBLAZE_64_PLT:
     case BFD_RELOC_MICROBLAZE_64_GOTOFF:
     case BFD_RELOC_MICROBLAZE_32_GOTOFF:
+    case BFD_RELOC_MICROBLAZE_64_TLSGD:
+    case BFD_RELOC_MICROBLAZE_64_TLSLD:
+    case BFD_RELOC_MICROBLAZE_32_TLSDTPMOD:
+    case BFD_RELOC_MICROBLAZE_32_TLSDTPREL:
+    case BFD_RELOC_MICROBLAZE_64_TLSDTPREL:
+    case BFD_RELOC_MICROBLAZE_64_TLSGOTTPREL:
+    case BFD_RELOC_MICROBLAZE_64_TLSTPREL:
       code = fixp->fx_r_type;
       break;
 
@@ -2306,6 +2459,12 @@ md_parse_option (int c, char * arg ATTRI
 {
   switch (c)
     {
+    case OPTION_EB:
+      target_big_endian = 1;
+      break;
+    case OPTION_EL:
+      target_big_endian = 0;
+      break;
     default:
       return 0;
     }
diff -purN --exclude=.gitignore --exclude=.git --exclude=patches binutils-microblaze/gas/config/tc-microblaze.h git.xilinx.com_microblaze-gnu_src_binutils/gas/config/tc-microblaze.h
--- binutils-microblaze/gas/config/tc-microblaze.h	2012-10-07 15:50:56.144063375 +0200
+++ git.xilinx.com_microblaze-gnu_src_binutils/gas/config/tc-microblaze.h	2012-09-28 23:26:11.242855000 +0200
@@ -23,8 +23,10 @@
 #define TC_MICROBLAZE 1
 
 #define TARGET_ARCH	bfd_arch_microblaze
+#ifndef TARGET_BYTES_BIG_ENDIAN
 /* Used to initialise target_big_endian.  */
 #define TARGET_BYTES_BIG_ENDIAN 1
+#endif
 
 #define IGNORE_NONSTANDARD_ESCAPES
 
@@ -75,7 +77,7 @@ extern const struct relax_type md_relax_
 
 #ifdef OBJ_ELF
 
-#define TARGET_FORMAT (target_big_endian ? "elf32-microblaze" : "elf32-microblaze-little")
+#define TARGET_FORMAT (target_big_endian ? "elf32-microblaze" : "elf32-microblazeel")
 
 #define ELF_TC_SPECIAL_SECTIONS \
   { ".sdata",		SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE }, \
diff -purN --exclude=.gitignore --exclude=.git --exclude=patches binutils-microblaze/gas/configure.tgt git.xilinx.com_microblaze-gnu_src_binutils/gas/configure.tgt
--- binutils-microblaze/gas/configure.tgt	2012-10-07 16:26:14.524077363 +0200
+++ git.xilinx.com_microblaze-gnu_src_binutils/gas/configure.tgt	2012-09-28 23:26:11.262856292 +0200
@@ -54,7 +54,8 @@ case ${cpu} in
   m6811|m6812|m68hc12)	cpu_type=m68hc11 ;;
   m683??)		cpu_type=m68k ;;
   mep)			cpu_type=mep endian=little ;;
-  microblaze*)		cpu_type=microblaze ;;
+  microblazeel*)	cpu_type=microblaze endian=little;;
+  microblaze*)		cpu_type=microblaze endian=big;;
   mips*el)		cpu_type=mips endian=little ;;
   mips*)		cpu_type=mips endian=big ;;
   mt)			cpu_type=mt endian=big ;;
diff -purN --exclude=.gitignore --exclude=.git --exclude=patches binutils-microblaze/include/elf/microblaze.h git.xilinx.com_microblaze-gnu_src_binutils/include/elf/microblaze.h
--- binutils-microblaze/include/elf/microblaze.h	2012-10-07 15:50:57.894275397 +0200
+++ git.xilinx.com_microblaze-gnu_src_binutils/include/elf/microblaze.h	2012-09-28 23:26:27.183157579 +0200
@@ -50,6 +50,15 @@ START_RELOC_NUMBERS (elf_microblaze_relo
   RELOC_NUMBER (R_MICROBLAZE_GOTOFF_64, 19) /* Offset relative to GOT.  */
   RELOC_NUMBER (R_MICROBLAZE_GOTOFF_32, 20) /* Offset relative to GOT.  */
   RELOC_NUMBER (R_MICROBLAZE_COPY, 21)      /* Runtime copy.  */
+  RELOC_NUMBER (R_MICROBLAZE_TLS, 22)       /* TLS Reloc */
+  RELOC_NUMBER (R_MICROBLAZE_TLSGD, 23)     /* TLS General Dynamic */
+  RELOC_NUMBER (R_MICROBLAZE_TLSLD, 24)     /* TLS Local Dynamic */
+  RELOC_NUMBER (R_MICROBLAZE_TLSDTPMOD32, 25)  /* TLS Module ID */
+  RELOC_NUMBER (R_MICROBLAZE_TLSDTPREL32, 26)  /* TLS Offset Within TLS Block */
+  RELOC_NUMBER (R_MICROBLAZE_TLSDTPREL64, 27)  /* TLS Offset Within TLS Block */
+  RELOC_NUMBER (R_MICROBLAZE_TLSGOTTPREL32, 28)   /* TLS Offset From Thread Pointer */
+  RELOC_NUMBER (R_MICROBLAZE_TLSTPREL32, 29)   /* TLS Offset From Thread Pointer */
+  RELOC_NUMBER (R_MICROBLAZE_32_NONE, 30)
    
 END_RELOC_NUMBERS (R_MICROBLAZE_max)
 
diff -purN --exclude=.gitignore --exclude=.git --exclude=patches binutils-microblaze/ld/configure.tgt git.xilinx.com_microblaze-gnu_src_binutils/ld/configure.tgt
--- binutils-microblaze/ld/configure.tgt	2012-10-07 16:26:19.084387148 +0200
+++ git.xilinx.com_microblaze-gnu_src_binutils/ld/configure.tgt	2012-09-28 23:26:27.247246582 +0200
@@ -356,9 +356,18 @@ mcore-*-pe)		targ_emul=mcorepe ;
 mcore-*-elf)		targ_emul=elf32mcore
 			;;
 mep-*-elf)		targ_emul=elf32mep ;;
-microblaze*-linux*)
-			targ_emul="elf32mb_linux" ;;
-microblaze*)		targ_emul=elf32microblaze ;;
+microblazeel*-linux*)	targ_emul="elf32mbel_linux"
+			targ_extra_emuls="elf32mb_linux"
+			;;
+microblaze*-linux*)	targ_emul="elf32mb_linux"
+			targ_extra_emuls="elf32mbel_linux"
+			;;
+microblazeel*)		targ_emul=elf32microblazeel
+			targ_extra_emuls=elf32microblaze
+			;;
+microblaze*)		targ_emul=elf32microblaze
+			targ_extra_emuls=elf32microblazeel
+			;;
 mips*-*-pe)		targ_emul=mipspe ;
 			targ_extra_ofiles="deffilep.o pe-dll.o" ;;
 mips*-dec-ultrix*)	targ_emul=mipslit ;;
diff -purN --exclude=.gitignore --exclude=.git --exclude=patches binutils-microblaze/ld/emulparams/elf32mbel_linux.sh git.xilinx.com_microblaze-gnu_src_binutils/ld/emulparams/elf32mbel_linux.sh
--- binutils-microblaze/ld/emulparams/elf32mbel_linux.sh	1970-01-01 01:00:00.000000000 +0100
+++ git.xilinx.com_microblaze-gnu_src_binutils/ld/emulparams/elf32mbel_linux.sh	2012-09-28 23:26:27.247246582 +0200
@@ -0,0 +1,19 @@
+SCRIPT_NAME=elf
+OUTPUT_FORMAT="elf32-microblazeel"
+BIG_OUTPUT_FORMAT="elf32-microblaze"
+LITTLE_OUTPUT_FORMAT="elf32-microblazeel"
+TEXT_START_ADDR=0x10000000
+NONPAGED_TEXT_START_ADDR=0x28
+ALIGNMENT=4
+MAXPAGESIZE=0x1000
+COMMONPAGESIZE=0x1000
+ARCH=microblaze
+
+NOP=0x80000000
+
+TEMPLATE_NAME=elf32
+GENERATE_SHLIB_SCRIPT=yes
+GENERATE_PIE_SCRIPT=yes
+NO_SMALL_DATA=yes
+SEPARATE_GOTPLT=12
+      
diff -purN --exclude=.gitignore --exclude=.git --exclude=patches binutils-microblaze/ld/emulparams/elf32mb_linux.sh git.xilinx.com_microblaze-gnu_src_binutils/ld/emulparams/elf32mb_linux.sh
--- binutils-microblaze/ld/emulparams/elf32mb_linux.sh	2012-10-07 16:26:19.084387148 +0200
+++ git.xilinx.com_microblaze-gnu_src_binutils/ld/emulparams/elf32mb_linux.sh	2012-09-28 23:26:27.247246582 +0200
@@ -1,5 +1,7 @@
 SCRIPT_NAME=elf
 OUTPUT_FORMAT="elf32-microblaze"
+BIG_OUTPUT_FORMAT="elf32-microblaze"
+LITTLE_OUTPUT_FORMAT="elf32-microblazeel"
 TEXT_START_ADDR=0x10000000
 NONPAGED_TEXT_START_ADDR=0x28
 ALIGNMENT=4
diff -purN --exclude=.gitignore --exclude=.git --exclude=patches binutils-microblaze/ld/emulparams/elf32microblazeel.sh git.xilinx.com_microblaze-gnu_src_binutils/ld/emulparams/elf32microblazeel.sh
--- binutils-microblaze/ld/emulparams/elf32microblazeel.sh	1970-01-01 01:00:00.000000000 +0100
+++ git.xilinx.com_microblaze-gnu_src_binutils/ld/emulparams/elf32microblazeel.sh	2012-09-28 23:26:27.247246582 +0200
@@ -0,0 +1,25 @@
+SCRIPT_NAME=elfmicroblaze
+OUTPUT_FORMAT="elf32-microblazeel"
+BIG_OUTPUT_FORMAT="elf32-microblaze"
+LITTLE_OUTPUT_FORMAT="elf32-microblazeel"
+#TEXT_START_ADDR=0
+NONPAGED_TEXT_START_ADDR=0x28
+ALIGNMENT=4
+MAXPAGESIZE=4
+ARCH=microblaze
+EMBEDDED=yes
+
+NOP=0x80000000
+
+# Hmmm, there's got to be a better way.  This sets the stack to the
+# top of the simulator memory (2^19 bytes).
+#PAGE_SIZE=0x1000
+#DATA_ADDR=0x10000
+#OTHER_RELOCATING_SECTIONS='.stack 0x7000 : { _stack = .; *(.stack) }'
+#$@{RELOCATING+ PROVIDE (__stack = 0x7000);@}
+#OTHER_RELOCATING_SECTIONS='PROVIDE (_stack = _end + 0x1000);'
+
+TEMPLATE_NAME=elf32
+#GENERATE_SHLIB_SCRIPT=yes
+
+    
diff -purN --exclude=.gitignore --exclude=.git --exclude=patches binutils-microblaze/ld/emulparams/elf32microblaze.sh git.xilinx.com_microblaze-gnu_src_binutils/ld/emulparams/elf32microblaze.sh
--- binutils-microblaze/ld/emulparams/elf32microblaze.sh	2012-10-07 15:50:58.024378149 +0200
+++ git.xilinx.com_microblaze-gnu_src_binutils/ld/emulparams/elf32microblaze.sh	2012-09-28 23:26:27.247246582 +0200
@@ -1,5 +1,7 @@
 SCRIPT_NAME=elfmicroblaze
 OUTPUT_FORMAT="elf32-microblaze"
+BIG_OUTPUT_FORMAT="elf32-microblaze"
+LITTLE_OUTPUT_FORMAT="elf32-microblazeel"
 #TEXT_START_ADDR=0
 NONPAGED_TEXT_START_ADDR=0x28
 ALIGNMENT=4
diff -purN --exclude=.gitignore --exclude=.git --exclude=patches binutils-microblaze/ld/Makefile.am git.xilinx.com_microblaze-gnu_src_binutils/ld/Makefile.am
--- binutils-microblaze/ld/Makefile.am	2012-10-07 16:26:19.084387148 +0200
+++ git.xilinx.com_microblaze-gnu_src_binutils/ld/Makefile.am	2012-09-28 23:26:27.237225840 +0200
@@ -234,6 +234,7 @@ ALL_EMULATION_SOURCES = \
 	eelf32mb_linux.c \
 	eelf32mcore.c \
 	eelf32mep.c \
+	eelf32microblazeel.c \
 	eelf32microblaze.c \
 	eelf32mipswindiss.c \
 	eelf32moxie.c \
@@ -1075,6 +1076,9 @@ eelf32m32c.c: $(srcdir)/emulparams/elf32
   $(ELF_DEPS) $(srcdir)/emultempl/needrelax.em \
   $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf32m32c "$(tdir_m32c)"
+eelf32mbel_linux.c: $(srcdir)/emulparams/elf32mbel_linux.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32mbel_linux "$(tdir_microblazeel)"
 eelf32mb_linux.c: $(srcdir)/emulparams/elf32mb_linux.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf32mb_linux "$(tdir_microblaze)"
@@ -1084,6 +1088,9 @@ eelf32mcore.c: $(srcdir)/emulparams/elf3
 eelf32mep.c: $(srcdir)/emulparams/elf32mep.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/mep.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf32mep "$(tdir_mep)"
+eelf32microblazeel.c: $(srcdir)/emulparams/elf32microblazeel.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elfmicroblaze.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32microblazeel "$(tdir_microblazeel)"
 eelf32microblaze.c: $(srcdir)/emulparams/elf32microblaze.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elfmicroblaze.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf32microblaze "$(tdir_microblaze)"
diff -purN --exclude=.gitignore --exclude=.git --exclude=patches binutils-microblaze/ld/Makefile.in git.xilinx.com_microblaze-gnu_src_binutils/ld/Makefile.in
--- binutils-microblaze/ld/Makefile.in	2012-10-07 16:26:19.084387148 +0200
+++ git.xilinx.com_microblaze-gnu_src_binutils/ld/Makefile.in	2012-09-28 23:26:27.237225840 +0200
@@ -540,6 +540,7 @@ ALL_EMULATION_SOURCES = \
 	eelf32mb_linux.c \
 	eelf32mcore.c \
 	eelf32mep.c \
+	eelf32microblazeel.c \
 	eelf32microblaze.c \
 	eelf32mipswindiss.c \
 	eelf32moxie.c \
@@ -2528,6 +2529,9 @@ eelf32m32c.c: $(srcdir)/emulparams/elf32
   $(ELF_DEPS) $(srcdir)/emultempl/needrelax.em \
   $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf32m32c "$(tdir_m32c)"
+eelf32mbel_linux.c: $(srcdir)/emulparams/elf32mbel_linux.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32mbel_linux "$(tdir_microblazeel)"
 eelf32mb_linux.c: $(srcdir)/emulparams/elf32mb_linux.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf32mb_linux "$(tdir_microblaze)"
@@ -2537,6 +2541,9 @@ eelf32mcore.c: $(srcdir)/emulparams/elf3
 eelf32mep.c: $(srcdir)/emulparams/elf32mep.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/mep.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf32mep "$(tdir_mep)"
+eelf32microblazeel.c: $(srcdir)/emulparams/elf32microblazeel.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elfmicroblaze.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32microblazeel "$(tdir_microblazeel)"
 eelf32microblaze.c: $(srcdir)/emulparams/elf32microblaze.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elfmicroblaze.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf32microblaze "$(tdir_microblaze)"
diff -purN --exclude=.gitignore --exclude=.git --exclude=patches binutils-microblaze/opcodes/microblaze-dis.c git.xilinx.com_microblaze-gnu_src_binutils/opcodes/microblaze-dis.c
--- binutils-microblaze/opcodes/microblaze-dis.c	2012-10-07 16:26:20.264126561 +0200
+++ git.xilinx.com_microblaze-gnu_src_binutils/opcodes/microblaze-dis.c	2012-09-28 23:26:34.163589882 +0200
@@ -65,6 +65,15 @@ get_field_imm5 (long instr)
 }
 
 static char *
+get_field_imm5_mbar (long instr)
+{
+  char tmpstr[25];
+
+  sprintf(tmpstr, "%d", (short)((instr & IMM5_MBAR_MASK) >> IMM_MBAR));
+  return(strdup(tmpstr));
+}
+
+static char *
 get_field_rfsl (long instr)
 {
   char tmpstr[25];
@@ -130,6 +139,12 @@ get_field_special (long instr, struct op
     case REG_TLBSX_MASK :
       strcpy (spr, "tlbsx");
       break;
+    case REG_SHR_MASK :
+      strcpy (spr, "shr");
+      break;
+    case REG_SLR_MASK :
+      strcpy (spr, "slr");
+      break;
     default :
       if (((((instr & IMM_MASK) >> IMM_LOW) ^ op->immval_mask) & 0xE000)
           == REG_PVR_MASK)
@@ -368,12 +383,19 @@ print_insn_microblaze (bfd_vma memaddr, 
 	case INST_TYPE_R1:
 	  print_func (stream, "\t%s", get_field_r1 (inst));
 	  break;
-	case INST_TYPE_RD_R1_SPECIAL:
-	  print_func (stream, "\t%s, %s", get_field_rd (inst), get_field_r2 (inst));
+	case INST_TYPE_R1_R2_SPECIAL:
+	  print_func (stream, "\t%s, %s", get_field_r1 (inst), get_field_r2 (inst));
 	  break;
 	case INST_TYPE_RD_IMM15:
 	  print_func (stream, "\t%s, %s", get_field_rd (inst), get_field_imm15 (inst));
 	  break;
+        /* For mbar insn.  */
+        case INST_TYPE_IMM5:
+          print_func (stream, "\t%s", get_field_imm5_mbar (inst));
+          break;
+        /* For mbar 16 or sleep insn.  */
+        case INST_TYPE_NONE:
+          break;
 	/* For tuqula instruction */
 	case INST_TYPE_RD:
 	  print_func (stream, "\t%s", get_field_rd (inst));
diff -purN --exclude=.gitignore --exclude=.git --exclude=patches binutils-microblaze/opcodes/microblaze-opc.h git.xilinx.com_microblaze-gnu_src_binutils/opcodes/microblaze-opc.h
--- binutils-microblaze/opcodes/microblaze-opc.h	2012-10-07 15:50:59.294047783 +0200
+++ git.xilinx.com_microblaze-gnu_src_binutils/opcodes/microblaze-opc.h	2012-09-28 23:26:34.163589882 +0200
@@ -45,7 +45,7 @@
 #define INST_TYPE_R1_RFSL    15
 
 /* New insn type for insn cache.  */
-#define INST_TYPE_RD_R1_SPECIAL 16
+#define INST_TYPE_R1_R2_SPECIAL 16
 
 /* New insn type for msrclr, msrset insns.  */
 #define INST_TYPE_RD_IMM15    17
@@ -56,6 +56,9 @@
 /* New insn type for t*put.  */
 #define INST_TYPE_RFSL  19
 
+/* For mbar.  */
+#define INST_TYPE_IMM5 20
+
 #define INST_TYPE_NONE 25
 
 
@@ -76,8 +79,8 @@
 #define OPCODE_MASK_H2  0xFC1F0000  /* High 6 and bits 20-16.  */
 #define OPCODE_MASK_H12 0xFFFF0000  /* High 16.  */
 #define OPCODE_MASK_H4  0xFC0007FF  /* High 6 and low 11 bits.  */
-#define OPCODE_MASK_H13S 0xFFE0EFF0 /* High 11 and 15:1 bits and last 
-				       nibble of last byte for spr.  */
+#define OPCODE_MASK_H13S 0xFFE0E7F0 /* High 11 16:18 21:27 bits, 19:20 bits
+                                       and last nibble of last byte for spr.  */
 #define OPCODE_MASK_H23S 0xFC1FC000 /* High 6, 20-16 and 15:1 bits and last 
 				       nibble of last byte for spr.  */
 #define OPCODE_MASK_H34 0xFC00FFFF  /* High 6 and low 16 bits.  */
@@ -92,11 +95,13 @@
 
 /* New Mask for msrset, msrclr insns.  */
 #define OPCODE_MASK_H23N  0xFC1F8000 /* High 6 and bits 11 - 16.  */
+/* Mask for mbar insn.  */
+#define OPCODE_MASK_HN 0xFF020004 /* High 16 bits and bits 14, 29.  */
 
 #define DELAY_SLOT 1
 #define NO_DELAY_SLOT 0
 
-#define MAX_OPCODES 280
+#define MAX_OPCODES 286
 
 struct op_code_struct
 {
@@ -166,10 +171,12 @@ struct op_code_struct
   {"srl",   INST_TYPE_RD_R1, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x90000041, OPCODE_MASK_H34, srl, logical_inst },
   {"sext8", INST_TYPE_RD_R1, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x90000060, OPCODE_MASK_H34, sext8, logical_inst },
   {"sext16",INST_TYPE_RD_R1, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x90000061, OPCODE_MASK_H34, sext16, logical_inst },
-  {"wic",   INST_TYPE_RD_R1_SPECIAL, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x90000068, OPCODE_MASK_H34B, wic, special_inst },
-  {"wdc",   INST_TYPE_RD_R1_SPECIAL, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x90000064, OPCODE_MASK_H34B, wdc, special_inst },
-  {"wdc.clear", INST_TYPE_RD_R1_SPECIAL, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x90000066, OPCODE_MASK_H34B, wdcclear, special_inst },    
-  {"wdc.flush", INST_TYPE_RD_R1_SPECIAL, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x90000074, OPCODE_MASK_H34B, wdcflush, special_inst },
+  {"wic",   INST_TYPE_R1_R2_SPECIAL, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x90000068, OPCODE_MASK_H34B, wic, special_inst },
+  {"wdc",   INST_TYPE_R1_R2_SPECIAL, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x90000064, OPCODE_MASK_H34B, wdc, special_inst },
+  {"mbar",  INST_TYPE_IMM5, INST_PC_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xB8020004, OPCODE_MASK_HN, mbar, special_inst },
+  {"sleep", INST_TYPE_NONE, INST_PC_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xBA020004, OPCODE_MASK_HN, invalid_inst, special_inst }, /* translates to mbar 16.  */
+  {"wdc.clear", INST_TYPE_R1_R2_SPECIAL, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x90000066, OPCODE_MASK_H34B, wdcclear, special_inst },    
+  {"wdc.flush", INST_TYPE_R1_R2_SPECIAL, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x90000074, OPCODE_MASK_H34B, wdcflush, special_inst },
   {"mts",   INST_TYPE_SPECIAL_R1, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_MTS, 0x9400C000, OPCODE_MASK_H13S, mts, special_inst },
   {"mfs",   INST_TYPE_RD_SPECIAL, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_MFS, 0x94008000, OPCODE_MASK_H23S, mfs, special_inst },
   {"br",    INST_TYPE_R2, INST_PC_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x98000000, OPCODE_MASK_H124, br, branch_inst },
@@ -220,12 +227,18 @@ struct op_code_struct
   {"bgei",  INST_TYPE_R1_IMM, INST_PC_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xBCA00000, OPCODE_MASK_H1, bgei, branch_inst },
   {"bgeid", INST_TYPE_R1_IMM, INST_PC_OFFSET, DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xBEA00000, OPCODE_MASK_H1, bgeid, branch_inst },
   {"lbu",   INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xC0000000, OPCODE_MASK_H4, lbu, memory_load_inst },
+  {"lbur",  INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xC0000200, OPCODE_MASK_H4, lbur, memory_load_inst },
   {"lhu",   INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xC4000000, OPCODE_MASK_H4, lhu, memory_load_inst },
+  {"lhur",  INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xC4000200, OPCODE_MASK_H4, lhur, memory_load_inst },
   {"lw",    INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xC8000000, OPCODE_MASK_H4, lw, memory_load_inst },
+  {"lwr",   INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xC8000200, OPCODE_MASK_H4, lwr, memory_load_inst },
   {"lwx",   INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xC8000400, OPCODE_MASK_H4, lwx, memory_load_inst },
   {"sb",    INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xD0000000, OPCODE_MASK_H4, sb, memory_store_inst },
+  {"sbr",   INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xD0000200, OPCODE_MASK_H4, sbr, memory_store_inst },
   {"sh",    INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xD4000000, OPCODE_MASK_H4, sh, memory_store_inst },
+  {"shr",   INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xD4000200, OPCODE_MASK_H4, shr, memory_store_inst },
   {"sw",    INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xD8000000, OPCODE_MASK_H4, sw, memory_store_inst },
+  {"swr",   INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xD8000200, OPCODE_MASK_H4, swr, memory_store_inst },
   {"swx",   INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xD8000400, OPCODE_MASK_H4, swx, memory_store_inst },
   {"lbui",  INST_TYPE_RD_R1_IMM, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xE0000000, OPCODE_MASK_H, lbui, memory_load_inst },
   {"lhui",  INST_TYPE_RD_R1_IMM, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xE4000000, OPCODE_MASK_H, lhui, memory_load_inst },
@@ -256,6 +269,8 @@ struct op_code_struct
   {"fcmp.ge", INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x58000260, OPCODE_MASK_H4, fcmp_ge, arithmetic_inst },
   {"fcmp.un", INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x58000200, OPCODE_MASK_H4, fcmp_un, arithmetic_inst },
   {"flt",   INST_TYPE_RD_R1, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x58000280, OPCODE_MASK_H4, flt,   arithmetic_inst },
+  {"swapb",   INST_TYPE_RD_R1, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x900001E0, OPCODE_MASK_H4, swapb,   arithmetic_inst },
+  {"swaph",   INST_TYPE_RD_R1, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x900001E2, OPCODE_MASK_H4, swaph,   arithmetic_inst },
   {"fint",  INST_TYPE_RD_R1, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x58000300, OPCODE_MASK_H4, fint,  arithmetic_inst },
   {"fsqrt", INST_TYPE_RD_R1, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x58000380, OPCODE_MASK_H4, fsqrt, arithmetic_inst },
   {"tget",   INST_TYPE_RD_RFSL, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C001000, OPCODE_MASK_H32, tget,   anyware_inst },
@@ -388,6 +403,7 @@ struct op_code_struct
   {"tneaputd",  INST_TYPE_R2,    INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x4C0006E0, OPCODE_MASK_H34C, tneaputd,  anyware_inst },
   {"necaputd",  INST_TYPE_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x4C000760, OPCODE_MASK_H34C, necaputd,  anyware_inst },
   {"tnecaputd", INST_TYPE_R2,    INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x4C0007E0, OPCODE_MASK_H34C, tnecaputd, anyware_inst },
+  {"clz",      INST_TYPE_RD_R1, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x900000E0, OPCODE_MASK_H34, clz, special_inst },
   {"", 0, 0, 0, 0, 0, 0, 0, 0},
 };
 
@@ -405,5 +421,8 @@ char pvr_register_prefix[] = "rpvr";
 #define MIN_IMM15 ((int) 0x0000)
 #define MAX_IMM15 ((int) 0x7fff)
 
+#define MIN_IMM5  ((int) 0x00000000)
+#define MAX_IMM5  ((int) 0x0000001f)
+
 #endif /* MICROBLAZE_OPC */
 
diff -purN --exclude=.gitignore --exclude=.git --exclude=patches binutils-microblaze/opcodes/microblaze-opcm.h git.xilinx.com_microblaze-gnu_src_binutils/opcodes/microblaze-opcm.h
--- binutils-microblaze/opcodes/microblaze-opcm.h	2012-10-07 15:50:59.294047783 +0200
+++ git.xilinx.com_microblaze-gnu_src_binutils/opcodes/microblaze-opcm.h	2012-09-28 23:26:34.163589882 +0200
@@ -25,18 +25,18 @@
 
 enum microblaze_instr
 {
-  add, rsub, addc, rsubc, addk, rsubk, addkc, rsubkc, cmp, cmpu,
+  add, rsub, addc, rsubc, addk, rsubk, addkc, rsubkc, clz, cmp, cmpu,
   addi, rsubi, addic, rsubic, addik, rsubik, addikc, rsubikc, mul, 
-  mulh, mulhu, mulhsu,
+  mulh, mulhu, mulhsu,swapb,swaph,
   idiv, idivu, bsll, bsra, bsrl, get, put, nget, nput, cget, cput,
   ncget, ncput, muli, bslli, bsrai, bsrli, mului, or, and, xor,
   andn, pcmpbf, pcmpbc, pcmpeq, pcmpne, sra, src, srl, sext8, sext16, 
-  wic, wdc, wdcclear, wdcflush, mts, mfs, br, brd,
+  wic, wdc, wdcclear, wdcflush, mts, mfs, mbar, br, brd,
   brld, bra, brad, brald, microblaze_brk, beq, beqd, bne, bned, blt,
   bltd, ble, bled, bgt, bgtd, bge, bged, ori, andi, xori, andni,
   imm, rtsd, rtid, rtbd, rted, bri, brid, brlid, brai, braid, bralid,
   brki, beqi, beqid, bnei, bneid, blti, bltid, blei, bleid, bgti,
-  bgtid, bgei, bgeid, lbu, lhu, lw, lwx, sb, sh, sw, swx, lbui, lhui, lwi,
+  bgtid, bgei, bgeid, lbu, lbur, lhu, lhur, lw, lwr, lwx, sb, sbr, sh, shr, sw, swr, swx, lbui, lhui, lwi,
   sbi, shi, swi, msrset, msrclr, tuqula, fadd, frsub, fmul, fdiv, 
   fcmp_lt, fcmp_eq, fcmp_le, fcmp_gt, fcmp_ne, fcmp_ge, fcmp_un, flt, 
   fint, fsqrt, 
@@ -78,6 +78,8 @@ enum microblaze_instr_type
 #define REG_BTR_MASK 0x800b
 #define REG_EDR_MASK 0x800d
 #define REG_PVR_MASK 0xa000
+#define REG_SLR_MASK 0x8800
+#define REG_SHR_MASK 0x8802
 
 #define REG_PID_MASK   0x9000
 #define REG_ZPR_MASK   0x9001
@@ -99,6 +101,8 @@ enum microblaze_instr_type
 #define REG_FSR 39 /* FPU Status reg.  */
 #define REG_BTR 43 /* Branch Target reg.  */
 #define REG_EDR 45 /* Exception reg.  */
+#define REG_SHR 50 /* Stack High reg.  */
+#define REG_SLR 51 /* Stack Low reg.  */
 #define REG_PVR 40960 /* Program Verification reg.  */
 
 #define REG_PID   36864 /* MMU: Process ID reg.  */
@@ -121,6 +125,7 @@ enum microblaze_instr_type
 #define RA_LOW  16 /* Low bit for RA.  */
 #define RB_LOW  11 /* Low bit for RB.  */
 #define IMM_LOW  0 /* Low bit for immediate.  */
+#define IMM_MBAR 21 /* low bit for mbar instruction.  */
 
 #define RD_MASK 0x03E00000
 #define RA_MASK 0x001F0000
@@ -130,6 +135,9 @@ enum microblaze_instr_type
 /* Imm mask for barrel shifts.  */
 #define IMM5_MASK 0x0000001F
 
+/* Imm mask for mbar.  */
+#define IMM5_MBAR_MASK 0x03E00000
+
 /* FSL imm mask for get, put instructions.  */
 #define  RFSL_MASK 0x000000F
 
